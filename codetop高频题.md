codetop高频题

2022-3-25 携程笔试emo后发奋图强



## ==2022-5-19计划==

**链表的奇偶重排**

**删除有序链表中重复的元素-I**

**删除有序链表中重复的元素-II**

**二叉树的前序遍历 递归与非递归**



**对称的二叉树**

**二叉树的最大深度 递归和层序两种方法**

**判断是不是二叉搜索树**

**输出二叉树的右视图**

 **二叉搜索树的最近公共祖先**

**在二叉树中找到两个节点的最近公共祖先**

**用两个栈实现队列**

**包含min函数的栈**



**[剑指 Offer II 025. 链表中的两数相加](https://leetcode.cn/problems/lMSNwu/)**

**[剑指 Offer 51. 数组中的逆序对 ](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)** 牛客链接  [**数组中的逆序对**](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=295&tqId=23260&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

今天到动态规划结束

-------------

| 牛客的Top101题目                                             | 方法和完成情况            |
| ------------------------------------------------------------ | ------------------------- |
| **[反转链表](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&tqId=23286&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)** | **迭代和递归两种方法** ✅  |
| [**链表内指定区间反转**](https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&tqId=654&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) | 要再做几遍✅               |
| [**链表中的节点每k个一组翻转**](https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tqId=722&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) | ✅                         |
| [**合并k个已排序的链表**](https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=295&tqId=724&ru=%2Fpractice%2Fb49c3dc907814e9bbfa8437c251b028e&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) | 牛客没完全通过            |
| [**链表中环的入口结点（环形链表返回节点）**](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=295&tqId=23449&ru=%2Fpractice%2Fb49c3dc907814e9bbfa8437c251b028e&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295) | **哈希和双指针两种方法**✅ |
| [**链表中倒数最后k个结点**](https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=295&tqId=1377477&ru=%2Fpractice%2F253d2c59ec3e4bc68da16833f79a38e4&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295) | 快慢双指针 ✅              |
| [**删除链表的倒数第n个节点**](https://www.nowcoder.com/practice/f95dcdafbde44b22a6d741baf71653f6?tpId=295&tqId=727&ru=%2Fpractice%2F886370fe658f41b498d40fb34ae76ff9&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295) | 怎么回事，这题竟然不会了❌ |
| [**两个链表的第一个公共结点**](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=295&tqId=23257&ru=%2Fpractice%2Ff95dcdafbde44b22a6d741baf71653f6&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295) | ✅                         |
| [**链表相加(二)**](https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=295&tqId=1008772&ru=%2Fpractice%2F6ab1d9a29e88450685099d45c9e31e46&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295) | ✅                         |
| **[判断一个链表是否为回文结构](https://www.nowcoder.com/practice/3fed228444e740c8be66232ce8b87c2f?tpId=295&tqId=1008769&ru=%2Fpractice%2Ff23604257af94d939848729b1a5cda08&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)** | 栈 ✅                      |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
| [**求二叉树的层序遍历**](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=295&tqId=644&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) | ✅                         |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |
|                                                              |                           |











## ==必须掌握的排序算法✔==

![image-20220519184103678](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220519184103678.png)



#### 手写快排和归并排序

[视频参考](https://www.bilibili.com/video/BV1Ey4y1k7s1?spm_id_from=333.337.search-card.all.click)

#### [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

用**==快排==**和**==归并排序==**做这一题

#### 快排

```java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }

    public void quickSort(int[] nums, int left, int right) {
        int l = left;
        int r = right;
        int mid = nums[(left + right) / 2];
        int tmp = 0;
        while (l < r) {
            while (nums[l] < mid) {
                l++;
            }
            while (nums[r] > mid) {
                r--;
            }
            if (l >= r) {
                break;
            }
            // 开始交换
            tmp = nums[r];
            nums[r] = nums[l];
            nums[l] = tmp;
            // 排除死锁
            if (nums[l] == mid) {
                r--;
            }
            if (nums[r] == mid) {
                l++;
            }
        }
        if (l == r) {
            l++;
            r--;
        }
        if (left < r) {
            quickSort(nums, left, r);
        }
        if (l < right) {
            quickSort(nums, l, right);
        }
    }
}
```

#### 归并排序

```java
class Solution {
    public int[] sortArray(int[] nums) {
        mergeSort(nums, 0, nums.length - 1);
        return nums;
    }

    // 归并排序
    public void mergeSort(int[] nums, int start, int end) {
        if (start >= end) {
            return;
        }
        int mid = (start + end) / 2;
        mergeSort(nums, start, mid);
        mergeSort(nums, mid + 1, end);
        int i = start;
        int j = mid + 1;
        int cur = 0;
        // 创建临时数组存放元素
        int[] tmp = new int[end - start + 1];
        while (i <= mid && j <= end) {
            if (nums[i] <= nums[j]) {
                tmp[cur++] = nums[i++];
            } else {
                tmp[cur++] = nums[j++];
            }
        }
        // 将剩余的元素入组
        while (i <= mid) {
            tmp[cur++] = nums[i++];
        }
        while (j <= end) {
            tmp[cur++] = nums[j++];
        }
        // 将存放临时元素的tmp数组，变成目标数组nums
        for(int z = 0; z < tmp.length; z++){
            nums[z + start] = tmp[z];
        }
    }
}
```

为了便于理解归并排序的两个临时数组，[见下图](https://www.bilibili.com/video/BV1Tp4y1v7tS?spm_id_from=333.337.search-card.all.click)：

在 将存放临时元素的tmp数组，变成目标数组nums的过程中，**注意要加上start变量**

![image-20220515203350636](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220515203350636.png)



## ==中厂高频==

#### [206. 反转链表](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)

方法一：迭代法

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head, pre = null;
        while (cur != null) {
            ListNode tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
```

方法二：递归

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        // base case
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```

方法三：用栈的思路做

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        Stack<ListNode> stack = new Stack<>();
        ListNode cur = head;
        // 将所有节点放入栈中
        while (cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
        ListNode dummy = new ListNode(-1);
        ListNode tmp = dummy;
        while (!stack.isEmpty()) {
            // tmp是dummy, 所以要用tmp.next表示第一个节点
            tmp.next = stack.pop();
            tmp = tmp.next;
        }
        tmp.next = null;
        return dummy.next;
    }
}
```



#### [**链表内指定区间反转**](https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&tqId=654&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

```java
public class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
		ListNode dummy = new ListNode(-1);
		dummy.next = head;
		ListNode pre = dummy;
		ListNode start = head;
		for (int i = 1; i < m; i ++ ) {
			pre = start;
			start = start.next;
		}
		// reverse
		for (int i = 0; i < n - m; i ++ ) {
			ListNode temp = start.next;
			start.next = temp.next;
			temp.next = pre.next;
			pre.next = temp;
		}
		return dummy.next;
	}
}
```



#### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

[视频](https://www.bilibili.com/video/BV1CB4y1K77p?spm_id_from=333.1007.top_right_bar_window_history.content.click)

[牛客链接](https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=295&tqId=1008889&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int left = 0;
        int right = 0;
        int maxLen = 0;
        HashSet<Character> set = new HashSet<>();
        while (left < s.length() && right < s.length()) {
            if (set.contains(s.charAt(right))) {
                set.remove(s.charAt(left));
                left++;
            } else {
                set.add(s.charAt(right));
                right++;
            }
            int curLen = right - left;
            maxLen = Math.max(maxLen, curLen);
        }
        return maxLen;
    }
}
```

考察**滑动窗口**，无重复可以联想到用Set集合来维护，用两个指针来维护窗口两侧，如果右侧的指针所指的元素已经在Set集合中出现，则说明left所指的元素已经进来Set集合过了，故移除左边的元素，并且指针右移。

[牛客链接](https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=295&tqId=1008889&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)的题解，注意牛客是基于数组的用**arr[i]**取出元素，而力扣是字符串，用**s.charAt(i)**来取值



#### [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int res = 0;
        int[][] dp = new int[m + 1][n + 1];
        // 初始化
        dp[0][0] = 0;
        for (int i = 0; i < m; i++) {
            dp[i][0] = 0;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 0;
        }
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                // 前一组相等的话，再之前基础上加1即可
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 前一组不相等的话，这组为0即可
                    dp[i][j] = 0;
                }
                res = Math.max(res, dp[i][j]);
            }
        }
        return res;
    }
}
```

**动态规划**

[题解参考](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/solution/zhe-yao-jie-shi-ken-ding-jiu-dong-liao-by-hyj8/)

`dp`状态方程表示以长度为i和j结尾的二维数组的最大公共后缀长度

两次for循环就相当于把所有的`dp[i][j]`的可能性全部列举出来了，所以就是相当于穷举所有可能，通过**比较前一个`dp[i - 1][j - 1]`是否相等**，**相等就加1，否则就置为0**，最后再通过与前置的初始为0的res，比较出一个更大的答案。



#### [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)

[视频](https://www.bilibili.com/video/BV1mE411S7kp?spm_id_from=333.1007.top_right_bar_window_history.content.click)

```java 
class LRUCache {

    LinkedHashMap<Integer, Integer> map;
    int capacity;

    public LRUCache(int capacity) {
        map = new LinkedHashMap<>(capacity + 1, 0.75f, true);
        this.capacity = capacity;
    }
    
    public int get(int key) {
        if (!map.containsKey(key)) return -1;
        return map.get(key);
    }
    
    public void put(int key, int value) {
        map.put(key, value);
        if (map.size() > capacity) {
            Iterator it = map.keySet().iterator();
            map.remove(it.next());
        }
    }
}
```



#### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

[视频](https://www.bilibili.com/video/BV1JA411e7MH?spm_id_from=333.880.my_history.page.click)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        Queue<Integer> queue = new PriorityQueue<>();
        for (int num : nums) {
            if (queue.size() < k) {
                queue.add(num);
            } else if (queue.peek() < num) {
                queue.remove(queue.peek());
                queue.add(num);
            }
        }
        return queue.poll();
    }
}
```

不要使用自带的sort函数，这题使用的是**优先队列**，优先队列是**默认升序排列**，其实优先队列就是小根堆先将前k个num构建成长度为k的优先队列，如果优先队列的最大值小于增强for遍历到的num，则将num与优先队列的最大值进行替换。

[牛客链接](https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=295&tqId=44581&ru=%2Fpractice%2Fb56799ebfd684fb394bd315e89324fb4&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj)



#### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

方法一：

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if(nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return new int[]{0, 0};
    }
}
```

方法二：

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.get(target - nums[i]) != null) {
                return new int[]{map.get(target - nums[i]), i};
            } else {
                map.put(nums[i], i);
            }
        }
        return new int[]{0, 0};
    }
}
```



#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

[视频](https://www.bilibili.com/video/BV1oE411Q7cS?spm_id_from=333.880.my_history.page.click)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new LinkedList<>();
        // 去重
        HashSet<List<Integer>> set = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            // 注意left取i + 1，而不是0；right取nums.length - 1
            int left = i + 1;
            int right = nums.length - 1;
            while (left < right) {
                if (nums[i] + nums[left] + nums[right] == 0) {
                    set.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    left++;
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    right--;       
                }
            }
        }
        res.addAll(set);
        return res;
    }
}
```

牛客答案如下：

```java
import java.util.*;
public class Solution {
    public ArrayList<ArrayList<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        // 去重
        HashSet<ArrayList<Integer>> set = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            // 注意left取i + 1，而不是0；right取nums.length - 1
            int left = i + 1;
            int right = nums.length - 1;
            while (left < right) {
                if (nums[i] + nums[left] + nums[right] == 0) {
                    // 牛客这一步与力扣不同，需要传入new ArrayList<>()
                    set.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right])));
                    left++;
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    right--;       
                }
            }
        }
        res.addAll(set);
        return res;
    }
}
```



#### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

[牛客链接](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=295&tqId=23267&ru=%2Fpractice%2F345e2ed5f81d4017bbb8cc6055b0b711&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null || l2 == null) {
            return (l1 == null) ? l2 : l1;
        }
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```



#### [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

[视频](https://www.bilibili.com/video/BV1eE411y7WC?spm_id_from=333.337.search-card.all.click)

[牛客链接](https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=295&tqId=658&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i1 = m - 1;
        int i2 = n - 1;
        int i = m + n - 1;
        while (i1 >= 0 && i2 >= 0) {
            // 按照题目要求：将nums2合并到nums1中
            if (nums1[i1] > nums2[i2]) {
                nums1[i] = nums1[i1];
                i1--;
                i--;
            } else {
                nums1[i] = nums2[i2];
                i2--;
                i--;
            }
        }
        // 将剩余的nums2元素全部加入nums1
        while (i2 >= 0) {
            nums1[i] = nums2[i2];
            i2--;
            i--;
        }
    }
}
```

按照题目要求：将`nums2` **合并** 到 `nums1` 中



#### ==[剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)==

```java
public class Solution {
    public int reversePairs(int[] nums) {
        int len = nums.length;

        if (len < 2) {
            return 0;
        }

        int[] copy = new int[len];
        for (int i = 0; i < len; i++) {
            copy[i] = nums[i];
        }

        int[] temp = new int[len];
        return reversePairs(copy, 0, len - 1, temp);
    }

    private int reversePairs(int[] nums, int left, int right, int[] temp) {
        if (left == right) {
            return 0;
        }

        int mid = left + (right - left) / 2;
        int leftPairs = reversePairs(nums, left, mid, temp);
        int rightPairs = reversePairs(nums, mid + 1, right, temp);

        if (nums[mid] <= nums[mid + 1]) {
            return leftPairs + rightPairs;
        }

        int crossPairs = mergeAndCount(nums, left, mid, right, temp);
        return leftPairs + rightPairs + crossPairs;
    }

    private int mergeAndCount(int[] nums, int left, int mid, int right, int[] temp) {
        for (int i = left; i <= right; i++) {
            temp[i] = nums[i];
        }

        int i = left;
        int j = mid + 1;

        int count = 0;
        for (int k = left; k <= right; k++) {

            if (i == mid + 1) {
                nums[k] = temp[j];
                j++;
            } else if (j == right + 1) {
                nums[k] = temp[i];
                i++;
            } else if (temp[i] <= temp[j]) {
                nums[k] = temp[i];
                i++;
            } else {
                nums[k] = temp[j];
                j++;
                count += (mid - i + 1);
            }
        }
        return count;
    }
}
```

这题使用的是**归并排序**，可以参见[官方题解](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/)，很容易听懂，这题比较难熟悉一下思路就行了



#### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

[视频](https://www.bilibili.com/video/BV1aK411N7fW?spm_id_from=333.1007.top_right_bar_window_history.content.click)

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode A = headA;
        ListNode B = headB;
        while (A != B) {
            A = (A == null) ? headB : A.next;
            B = (B == null) ? headA : B.next;
        }
        return A;
    }
}
```

A和B都走相同的步数，就一定可以在C点相遇，记得：比如B走完链表，要再次连接到A的首端

方法二：

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {       
        ListNode pointA = headA;
        ListNode pointB = headB;

        int lenA = getLen(headA);
        int lenB = getLen(headB);
        
        // 分类讨论，让较长的链表指针来指向短的链表的指针
        if (lenA > lenB) {
            int diff = lenA - lenB;
            while (diff > 0) {
                pointA = pointA.next;
                diff--;
            }
        } else {
            int diff = lenB - lenA;
            while (diff > 0) {
                pointB = pointB.next;
                diff--;
            }
        }

        // 让在同一相对位置的两个指针同时移动，直到pointA和pointB相等为止，即表示相遇
        while (pointA != pointB) {
            pointA = pointA.next;
            pointB = pointB.next;
        }
        return pointA;
    }

    // 计算链表的长度
    private int getLen(ListNode head) {
        ListNode cur = head;
        int len = 0;
        while (cur != null) {
            len++;
            cur = cur.next;
        }
        return len;
    }
}
```

[题解](https://www.bilibili.com/video/BV1Zq4y1C7kT?spm_id_from=333.788.top_right_bar_window_history.content.click)

本质就是将两个两个链表移动到对应的位置，同时移动，那么就一起到达交叉点位置，找一个返回即可

![image-20220527182755391](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220527182755391.png)





2022-3-26

#### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        char[] chars = s.toCharArray();
        for (char c : chars) {
            if (c == '(') {
                stack.push(')');
            } else if (c == '[') {
                stack.push(']');
            } else if (c == '{') {
                stack.push('}');
            // 这步表示只有右括号如"]}"的情况
            } else if (stack.isEmpty()) {
                return false;
            } else if (stack.pop() != c) {
                return false;
            }
        }
        return stack.isEmpty();
    }
}

```

注意：最后的返回的不是true，而是要看这个栈是否为空了



#### [148. 排序链表](https://leetcode.cn/problems/sort-list/)

```java
class Solution {
    public ListNode sortList(ListNode head) {
        return sort(head, null);
    }
    
	// 排序
    private ListNode sort(ListNode start, ListNode end) {
        if (start == end) return start;
        ListNode fast = start, slow = start;
        //注意点1. 是end而不是null，否则会出现空指针异常
        while (fast != end && fast.next != end) {
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode l2 = sort(slow.next, end);
        //注意点2. 要断开成两段
        slow.next = null;
        ListNode l1 = sort(start, slow);
        return merge(l1, l2);

    }

    // LC21 合并两个有序链表
    private ListNode merge(ListNode l1, ListNode l2) {
        if (l1 == null || l2 == null) {
            return (l1 == null) ? l2 : l1;
        }
        if (l1.val < l2.val) {
            l1.next = merge(l1.next, l2);
            return l1;
        } else {
            l2.next = merge(l1, l2.next);
            return l2;
        }
    }
}
```

[题解](https://leetcode.cn/problems/sort-list/solution/java-dai-ma-jian-ji-qing-xi-yi-dong-by-v-foig/)

时间复杂度是 O(nlogn) 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(n^2)），其中最适合链表的排序算法是归并排序，本题就采用**归并排序**，也就是找到中间的节点，将其分成两端，**分别排序**，最后**再后并**，所以要定义两个函数。



#### [14. 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)

2022-5-17 隔离于宣城方舱

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int len = strs.length;
        if (len == 0) {
            return "";
        }
        // 比如第一个的tmp就是题目中的"flower"
        String tmp = strs[0];
        // 比如跳过第一个，将"flow"与"flower"进行比较，所以i从1开始遍历
        for (int i = 1; i < len; i++) {
            tmp = compare(tmp, strs[i]);
        }
        return tmp;
    }

    // compare方法进行两两比较
    private String compare(String str1, String str2) {
        int len = Math.min(str1.length(), str2.length());
        // !!!!!!! 注意：for循环语句里面不要写i++ !!!!!!!
        for (int i = 0; i < len; ) {
            if (str1.charAt(i) == str2.charAt(i)) {
                i++;
            } else {
                return str1.substring(0, i);
            }
        }
        // 注意这里用str1和str2都可以，因为[0, len)它们是都包含的
        return str1.substring(0, len);
    }
}
```

**注意一个细节**就是i要进行判断才能累加，而**不是在for循环体里面加上i+**+，第一次遇到这种情况，记住了。[参考题解](https://www.bilibili.com/video/BV1ft4y1i7Y8?spm_id_from=333.337.search-card.all.click)



#### [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        // 去重
        HashSet<Integer> set = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            if (!set.contains(nums[i])) {
                set.add(nums[i]);
            }
        }
        int maxLen = 0;
        /**
      若当前遍历的数减一已经存在set中，则此数开头的序列必不可能最长，直接跳过进行下一次遍历，
      若此数减一不存在set中，则进行加一，再次判断是否在set中，直至跳出循环，更新长度
         */
        for (Integer num : set) {
            if (!set.contains(num - 1)) {
                int cur = num;
                int curLen = 1;
                while (set.contains(cur + 1)) {
                    cur++;
                    curLen++;
                }
                maxLen = Math.max(maxLen, curLen);
            }
        }
        return maxLen;
    }
}

```

**哈希**



#### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        LinkedList<int[]> res = new LinkedList<>();
        // 按区间的 start 升序排列
        Arrays.sort(intervals, (a, b) -> {return a[0] - b[0];});
        // cur相当于[[1,3],[4,6],[8,10],[15,18]]中的[1,3]
        int[] cur = intervals[0];
        for (int i = 1; i < intervals.length; i++) {
            // 相当于在[[1,3],[4,6],[8,10],[15,18]]中，[4,6]中的4大于[1,3]中的3，直接将[1,3]加入res
            if (intervals[i][0] > cur[1]) {
                res.add(cur);
                // 更新cur为[4,6]
                cur = intervals[i];
            } else {
                // 有重叠，比如在[[1,3],[2,6],[8,10],[15,18]]中取二维数组的第一个的第二位即更新[1,3]种cur[1] = 3
                cur[1] = Math.max(cur[1], intervals[i][1]);
            }
        }
        res.add(cur);
        // 因为返回的是二维数组，所以整理一下结果
        int[][] ans = new int[res.size()][2];
        for (int i = 0; i < res.size(); i++) {
            ans[i] = res.get(i);
        }
        return ans;
    }
}
```

[程序员刀刀](https://www.bilibili.com/video/BV12E411D7vJ?spm_id_from=333.337.search-card.all.click)



## ==滑动窗口==

#### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int right = 0;
        int windowSum = 0;
        int res = Integer.MAX_VALUE;
        while (right < nums.length) {
            // 扩大窗口
            windowSum += nums[right];
            right++;
            while (windowSum >= target && left < right) {
                // 窗口内的值超过target时，就更新答案res，并且缩小窗口
                res = Math.min(res, right - left);
                windowSum -= nums[left];
                left++;
            }
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }
}
```

这题是标准的滑动窗口算法，你只要看过前文 [滑动窗口算法框架](https://labuladong.github.io/article/fname.html?fname=滑动窗口技巧进阶) 就能轻松搞定。

不过需要强调的是，**题目说了 `nums` 数组中的元素都是正数，有了这个前提才能使用滑动窗口算法**，因为窗口扩大时窗口内元素之和必然增大，窗口缩小时窗口内元素之和必然减小。

如果 `nums` 数组中包含负数，则窗口扩大时元素和不见得就增大，窗口缩小时元素和不见得就减小，这种情况就不能单纯使用滑动窗口技巧了，可能需要混合动态规划和单调队列来做。



#### [169. 多数元素](https://leetcode.cn/problems/majority-element/)

```java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        int tmp = nums[0];
        for (int i = 0; i < nums.length; i++) {
            if (tmp == nums[i]) {
                count++;
            } else {
                count--;
                if (count == 0) {
                    tmp = nums[i + 1];
                }
            }
        }
        return tmp;
    }
}
```

评论区：从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个











## ==单调栈==

#### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Stack<Integer> stack = new Stack<>();
        int len = temperatures.length;
        int[] res = new int[len];
        for (int i = 0; i < len; i++) {
            // 维护单调递增的单调栈,因为题目要算距离，所以栈中存放的数坐标
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                res[stack.peek()] = i - stack.peek();
                stack.pop();
            }
            stack.push(i);
        }
        return res;
    }
}
```

[参考题解](https://www.bilibili.com/video/BV1Fu411q7Ub?spm_id_from=333.337.search-card.all.click)





## ==美团高频==

#### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 队列，里面维护的是滑动窗口的下标
        Deque<Integer> queue = new LinkedList<>();
        int[] res = new int[nums.length - k + 1];
        int resIndex = 0;
        for (int i = 0; i < nums.length; i++) {
            // 元素从左侧开始向右加入队列queue 👉👉👉
            // 头: 清理超期元素(清理i-k位置的元素是否等于queue.peekFirst()，即队列最左侧元素)
            if (!queue.isEmpty() && (queue.peekFirst() == i - k)) {
                queue.removeFirst();
            }
            // 尾: 维护单调递减队列(清除队列内<新入队元素的元素)
            while (!queue.isEmpty() && nums[i] > nums[queue.peekLast()]) {
                queue.removeLast();
            }
            // 尾: 新元素入队
            queue.add(i);
            // 头: 获取滑动窗口最大值(返回头部元素,即最左侧元素,i>=k -1时)
            if (i >= k - 1) {
                res[resIndex++] = nums[queue.peekFirst()];
            }
        }
        return res;
    }
}
```

[参考视频](https://www.bilibili.com/video/BV1wb4y1h79v?spm_id_from=333.337.search-card.all.click)

题目中的**双端队列**是从左向右添加元素的，所以

`queue.peekFirst()`指的是查看最左侧的元素，

`queue.peekLast()`指的是查看最右侧元素；

同样地，

`queue.removeFirst();`  指的是一出最左侧元素；

`queue.removeLast();`指的是移除最右侧元素



#### [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode res = null;
        for (ListNode list : lists) {
            res = merge2Lists(list, res);
        }
        return res;
    }

    // 基础题---206合并链表
    private ListNode merge2Lists(ListNode l1, ListNode l2) {
        if (l1 == null || l2 == null) {
            return (l1 == null) ? l2 : l1;
        }
        if (l1.val < l2.val) {
            l1.next = merge2Lists(l1.next, l2);
            return l1;
        } else {
            l2.next = merge2Lists(l1, l2.next);
            return l2;
        }
    }
}
```

在合并两个有序链表的基础上升级，即遍历多个链表，将其合并

牛客和力扣不一样，如果是集合形式那么就像下面这样做，用get方法依次取出每个元素进行比较，如下：

```
public class Solution {
    public ListNode mergeKLists(ArrayList<ListNode> lists) {
        int n = lists.size();
        if (n == 0) return null;
        ListNode sum = lists.get(0);
        for (int i = 1; i < lists.size(); i++) {
            sum = merge(sum, lists.get(i));
        }
        return sum;
    }
}
```



#### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

#### [**链表中的节点每k个一组翻转**](https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tqId=722&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        // base case
        if (head == null) return head;
        ListNode firstHead = head;
        ListNode firstTail = head;
        // 注意这里是 k - 1
        for (int i = 0; i < k - 1; i++) {
            firstTail = firstTail.next;
            if (firstTail == null) {
                return firstHead;
            }
        }
        ListNode secondHead = firstTail.next;
        firstTail.next = null;
        reverse(firstHead);
        firstHead.next = reverseKGroup(secondHead, k);
        return firstTail;
    }

    // 206. 链表反转
    private ListNode reverse(ListNode head) {
        ListNode cur = head;
        ListNode pre = null;
        while (cur != null) {
            ListNode tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
```

[题解视频](https://www.bilibili.com/video/BV1ng411w7LX?spm_id_from=333.337.search-card.all.click)

在反转链表的基础上扩展而来，见下图

![image-20220517170041970](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220517170041970.png)



#### [78. 子集](https://leetcode.cn/problems/subsets/)

**子集（元素无重、不可复选）**

比如输入`nums = [1, 2, 3]` 输出 `[ [],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3] ]`

```java
class Solution {

    List<List<Integer>> res = new ArrayList<>();// 存放符合条件结果的集合
    LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果

    public List<List<Integer>> subsets(int[] nums) {
        if (nums.length == 0) return res;
        dfs(nums, 0);
        return res;
    }
	
    // startIndex相当于是树的层数
    private void dfs(int[] nums, int start){
        res.add(new ArrayList<>(path));
        
        for (int i = start; i < nums.length; i++){
            path.add(nums[i]);
            dfs(nums, i + 1);
            path.removeLast();
        }
    }
}
```



#### [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

**子集/组合（元素可重、不可复选）**

比如输入 `nums = [1,2,2]`，你应该输出：

```java
[ [],[1],[2],[1,2],[2,2],[1,2,2] ]
```

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        // 先排序，让相同的元素靠在一起
        Arrays.sort(nums);
        dfs(nums, 0);
        return res;
    }

    private void dfs(int[] nums, int start) {
        res.add(new LinkedList<>(path));
        
        for (int i = start; i < nums.length; i++) {
            if (i > start && nums[i] == nums[i - 1]) {
                continue;
            }
            path.add(nums[i]);
            dfs(nums, i + 1);
            path.removeLast();
        }
    }
}
```



## ==岛屿问题（感染法）==

#### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

```java
class Solution {
    public int numIslands(char[][] grid) {
        int res = 0;
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 发现'1'就进行感染，即上下左右DFS
                if (grid[i][j] == '1') {
                    dfs(grid, i, j); 
                    res++;
                }
            }
        }
        return res;
    }

    // 探索(i, j)的上下左右
    23
    private void dfs(char[][] grid, int i, int j) {
        int m = grid.length;
        int n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == '0') {
            return;
        }
        // 感染过的变成水
        grid[i][j] = '0';
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
}
```

注意这题的dfs返回值是void，下一题算岛屿最大面积的dfs返回值是int

参见下一题的解释，dfs也可以这么写

![image-20220517214732326](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220517214732326.png)





#### [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int res = 0;
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 发现1就进行感染，即上下左右DFS
                if (grid[i][j] == 1) {
                    res = Math.max(res, dfs(grid, i, j));
                }
            }
        }
        return res;
    }

    // 探索(i, j)的上下左右
    private int dfs(int[][] grid, int i, int j) {
        int m = grid.length;
        int n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0) {
            return 0;
        }
        // 至此，说明(i, j)被感染的上下左右都为1，也就是面积至少为1了，然后再将其变为其他数，比如0
        grid[i][j] = 0;
        return dfs(grid, i + 1, j) + dfs(grid, i - 1, j)
             + dfs(grid, i, j + 1) + dfs(grid, i, j - 1) + 1;
    }
}
```

[参考动画](https://leetcode.cn/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-jian-dan-de-di-gui-tu-jie/)

说明一下，为什么感染时要将`grid[i][j]`设置0，当然也可以设置为其他，比如2，但设置为2的话，就要将终止条件改成

```java
if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] != 1) {
	return 0;
 }
```

这样就比较相当于人为制造麻烦了，不如直接将其变成“水”来的方便





#### [1254. 统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/)

```java
class Solution {
    // 主函数：计算封闭岛屿的数量
    public int closedIsland(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        // 初始化
        for (int i = 0; i < m; i++) {
            // 把靠左边的岛屿淹掉
            dfs(grid, i, 0);
            // 把靠右边的岛屿淹掉
            dfs(grid, i, n - 1);
        }
        for (int j = 0; j < n; j++) {
            // 把靠上边的岛屿淹掉
            dfs(grid, 0, j);
            // 把靠下边的岛屿淹掉
            dfs(grid, m - 1, j);
        }
 
        // 遍历 grid，剩下的岛屿都是封闭岛屿
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    res++;
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }

    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    private void dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        if (grid[i][j] == 1) {
            // 已经是海水了
            return;
        }
        // 将 (i, j) 变成海水
        grid[i][j] = 1;
        // 淹没上下左右的陆地
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
}
```

上一题说二维矩阵四周可以认为也是被海水包围的，所以靠边的陆地也算作岛屿。但这题**靠边的陆地不算作「封闭岛屿」**，所以要先初始化将岛屿数组周围先用水围起来，其他和[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)一样







## ==二叉树==

#### 二叉树的前中后序遍历 --- ==递归==

#### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

```java
class Solution {
    List<Integer> res = new LinkedList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        traversal(root);
        return res;
    }

    private void traversal(TreeNode root) {
        // 前序遍历：根左右
        if (root == null) return;
        res.add(root.val);
        traversal(root.left);
        traversal(root.right);
    }
}
```

#### [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

```java
class Solution {

    List<Integer> res = new LinkedList<>();

    public List<Integer> postorderTraversal(TreeNode root) {
        traversal(root);
        return res;
    }

    private void traversal(TreeNode root) {
        if (root == null) return;
        traversal(root.left);
        traversal(root.right);
        res.add(root.val);
    }
}
```

#### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

```java
class Solution {

    List<Integer> res = new LinkedList<>();
    
    public List<Integer> inorderTraversal(TreeNode root) {
        traversal(root);
        return res;
    }

    private void traversal(TreeNode root) {
        if (root == null) return;
        traversal(root.left);
        res.add(root.val);
        traversal(root.right);
    }
}
```



#### ==二叉树的前中后序遍历 --- 非递归==

参考视频： [B站郭郭](https://www.bilibili.com/video/BV15K4y1Y7Gz?spm_id_from=333.337.search-card.all.click)

#### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (res == null) return res;

        Stack<TreeNode> stack = new Stack<>();

        while (root != null || !stack.isEmpty()) {
            while (root != null) {
            	res.add(root.val);
            	stack.push(root);
            	root = root.left; // 因为是左根右所以：一路左下↙
        	}

            // 左下到头了，开始考虑右侧节点
            TreeNode cur = stack.pop(); 
            root = cur.right;
        }
        return res;
    }
}
```

总结：前序遍历的方向就是尽可能的往下走，直到左下角为null了，再stack栈pop一下，然后考虑右节点...

#### [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

**根左右**，这个要和前序遍历的思路一起样，只不过前序遍历的思路是想让遍历一直朝着左下角走，而中序遍历是要一直朝着右下角走，这样就能得到**"右左根"**的结果，然后再调用API的reverse即可变成中序遍历的**根左右**。

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        Stack<TreeNode> stack = new Stack<>();
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                res.add(root.val);
                stack.add(root);
                root = root.right;
            }
            TreeNode cur = stack.pop();
            root = cur.left;
        }
        Collections.reverse(res);
        return res;
    } 
}
```

#### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

```java
class Solution {  
    public List<Integer> inorderTraversal(TreeNode root) {
        // 左根右
        List<Integer> res = new LinkedList<>();
        Stack<TreeNode> stack = new Stack<>();
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
   //在这步加入res，正好也体现出与前序、后序的不同，中序正好在中间位置     
            res.add(root.val); 
            root = root.right;
        }
        return res;
    }
}
```



#### ==[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)==

```java
class Solution {

    List<Integer> res = new LinkedList<>();

    public boolean isValidBST(TreeNode root) {
        traversal(root);
        for (int i = 1; i < res.size(); i++) {
            // 前一个数大于后一个数就返回错误
            if (res.get(i - 1) >= res.get(i)) return false; 
        }
        return true;
    }

    private void traversal (TreeNode root) {
        if (root == null) return;
        traversal(root.left);
        res.add(root.val);
        traversal(root.right);
    }
}
```

回溯

**如果它是一个二叉搜索树，则如果它按中序遍历就一定是升序的**，因此可以先中序遍历(本题是递归)，然后将得到的list进行一次遍历，注意for循环是从i为1开始，防止下标越界异常



#### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

[牛客的链接](https://www.nowcoder.com/practice/8a2b2bf6c19b4f23a9bdb9b233eefa73?tpId=295&tqId=642&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

递归，分别算出左右子树的深度，再加1，终止条件就是root节点为空

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
}
```



#### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        return Math.abs(getDepth(root.left) - getDepth(root.right)) <=1 && isBalanced(root.left) && isBalanced(root.right);
    }

    // 104. 二叉树的最大深度
    public int getDepth(TreeNode root) {
        if (root == null) return 0;
        int left = getDepth(root.left);
        int right = getDepth(root.right);
        return Math.max(left, right) + 1;
    }
}
```

基于上面的计算**==二叉树的深度==**这题的基础上，判断它的左右子树深度之差是否在1以外，**并且递归操**

**作左右子树的左右子树**。（递归左右子树这个别忘记了！否则会有很多样例通不过）

[牛客链接](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=295&tqId=23250&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

```java
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if (root == null) return true;
        return Math.abs(getDepth(root.left) - getDepth(root.right)) <= 1 
            && IsBalanced_Solution(root.left)
            && IsBalanced_Solution(root.right);
    }
    
    private int getDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(getDepth(root.left), getDepth(root.right)) + 1;
    }
}
```



#### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return dfs(root.left, root.right);
    }
    // 判断左右节点是否对称
    private boolean dfs(TreeNode left, TreeNode right) {
        if (left == null && right == null) return true;
        if (left == null || right == null) return false;
        if (left.val != right.val) return false;
        return dfs(left.left, right.right) && dfs(left.right, right.left);
    }
}
```

对称二叉树这题很容易遗忘，

因为传入一个单独的节点不好判断这个树是否对称，所以思路就是构建一个深搜函数，用于检索左右节点是否对称，然后用root节点调用它(其实就是**重写isSymmetric方法**)。

[牛客链接](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=295&tqId=23452&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)



[**BM33** **二叉树的镜像**](https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=295&tqId=1374963&ru=%2Fpractice%2Fff05d44dfdb04e1d83bdbdab320efbcb&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj)

```java
public class Solution {
    public TreeNode Mirror (TreeNode pRoot) {
        // base case
        if (pRoot == null) return null;
        TreeNode temp = pRoot.left;
        pRoot.left = Mirror(pRoot.right);
        pRoot.right = Mirror(temp);
        return pRoot;
    }
}
```

**二叉树镜像这题和二叉树翻转一模一样**

**Q**： 为何需要暂存 rootroot 的左子节点？
**A**： 在递归右子节点 `root.left = mirrorTree(root.right);`和

`root.left=mirrorTree(root.right);”`执行完毕后， root.left的值已经发生改变，此时递归左子节点 mirrorTree(root.left)则会出问题。



#### [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

[牛客链接](https://www.nowcoder.com/practice/7298353c24cc42e3bd5f0e0bd3d1d759?tpId=295&tqId=1025038&ru=%2Fpractice%2Fe0cc33a83afe4530bcec46eba3325116&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj)

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null || root2 == null) {
            return (root1 == null) ? root2 : root1;
        }
        TreeNode mergedTreeNode = new TreeNode(root1.val + root2.val);
        mergedTreeNode.left = mergeTrees(root1.left, root2.left);
        mergedTreeNode.right = mergeTrees(root1.right, root2.right);
        return mergedTreeNode;
    }
}
```

试了一下，如果我没有加一开始的判断非空语句，会报出空指针异常，导致样例一个都通不过。



#### [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

[牛客链接](https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c?tpId=295&tqId=634&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

```java
class Solution {

    LinkedList<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> pathSum(TreeNode root, int target) {
        if (root == null) return res;
        dfs(root, target);
        return res;
    }

    private void dfs(TreeNode root, int target) {
        if (root == null) return;
        // 加入path进行尝试（注意不是加入最终的结果res中）
        path.add(root.val);
        // 加入了一个元素，那么就更新target就相应的减去加入的root
        target = target - root.val;
        if (target == 0 && root.left == null && root.right == null) {
            // 这才满足条件，于是加入到res中
            res.add(new LinkedList<>(path));
        }
        dfs(root.left, target);
        dfs(root.right, target);
        path.removeLast();
    }
}
```

牛客的代码如下：

```java
public class Solution {
    public boolean hasPathSum (TreeNode root, int sum) {
        // write code here
        if (root == null) return false;
        if (root.left == null && root.right == null && root.val == sum) {
            return true;
        }
        return hasPathSum(root.left, sum - root.val) 
            || hasPathSum(root.right, sum - root.val);
    }
}
```

==力扣的返回值和牛客不一样，这里先放过，先贴上牛客的代码，因为牛客比较简单一点==

本答案参考的是牛客的刷题模板，比较难，要多写，但相对其他答案还是比较好理解的，**只有当叶子节点的左右都为空且等于目标值sum，才返回true**，然后再递归左右子树，当然有递归就必须要用root作为递归的终止判别条件、



#### ==[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)==

[牛客链接](https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=295&tqId=1024325&ru=%2Fpractice%2F37548e94a270412c8b9fb85643c8ccc2&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return null;
        if (root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // 1. 左节点不为空且右节点为空，公共祖先必在左侧
        if (left != null && right == null) return left;
        // 2. 右节点不为空且左节点为空，公共祖先必在右侧
        if (right != null && left == null) return right;
        if (left != null && right != null) return root;
        return null;
    }
}
```

清晰易懂题解：[育树霖疯](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-q0aoe/)

牛客的答案

```java
    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        return findTargetNode(root, o1, o2).val;
    }
    
    private TreeNode findTargetNode(TreeNode root, int o1, int o2) {
        if (root == null || root.val == o1 || root.val == o2) return root;
        root.left = findTargetNode(root.left, o1, o2);
        root.right = findTargetNode(root.right, o1, o2);
        // 如果left为空，说明这两个节点在root结点的右子树上，我们只需要返回右子树查找的结果即可
        if (root.left == null) return root.right;
        // 同上
        if (root.right == null) return root.left;
        return root;
    }
}
```

牛客上的这个题目的p和q节点是int类型，而且返回值是int类型，所以这个答案它封装了这个方法，然后再调用它的val属性，从而达到返回值是int的目的。



#### ==[剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)==

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while(root != null) {
            if(root.val < p.val && root.val < q.val) // p,q 都在 root 的右子树中
                root = root.right; // 遍历至右子节点
            else if(root.val > p.val && root.val > q.val) // p,q 都在 root 的左子树中
                root = root.left; // 遍历至左子节点
            else {
                break; // 说明p和q分别在root的两边，退出循环，返回root
            }
        }
        return root;
    }
}
```



#### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        LinkedList<List<Integer>> res = new LinkedList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if (root == null) return res;
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> path = new LinkedList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.remove();
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
                path.add(node.val);
            }
            res.add(path);
        }
        return res;
    }
}
```

[牛客链接](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=295&tqId=644&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj) 答案

```java
import java.util.*;

public class Solution {
    public ArrayList<ArrayList<Integer>> levelOrder (TreeNode root) {
        // write code here
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        // 队列，用于存储元素
        Queue<TreeNode> queue = new LinkedList<>();
        // 根节点先入队
        queue.add(root);
        // 当队列不为空的时候
        while(!queue.isEmpty()) {
            // 队列的大小就是这一层的元素数量
            int size = queue.size();
            ArrayList<Integer> path = new ArrayList<>();
            // 开始遍历这一层的所有元素
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.remove();
                // 如果左节点不为空，则入队，作为下一层来遍历
                if(node.left != null) {
                    queue.add(node.left);
                }
                // 同上
                if (node.right != null) {
                    queue.add(node.right);
                }
                // 存储一层的节点
                path.add(node.val);
            }
            // 将一层所有的节点汇入到总的结果集中
            res.add(path);
        }
        return res;
    }
}
```



#### [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        // 这题如果不判空，会出现空指针异常
        if (root == null) return res;
        queue.add(root);
        boolean flag = true;
        while (!queue.isEmpty()) {
            int size = queue.size();
            LinkedList<Integer> path =new LinkedList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.remove();
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
                if (flag) {
                    path.addLast(node.val);
                } else {
                    path.addFirst(node.val);
                }
            }
            flag = !flag;
            res.add(path);
        }
        return res;
    }
}
```





#### ==做到现在，总结一下我所做过的二叉树的题目==

先做二叉树的**前中后序遍历（递归加迭代）** 紧接着再做**验证是否是二叉搜索树**，用的就是中序遍历成有序的数组 --> 再做求**二叉树的深度**的题目 --> 再做求**二叉树是否平衡**的问题 --> 判断收**二叉树是否对称**它的返回值是boolean，需要自己写一个dfs函数，判断三次 --> **镜像和翻转二叉树**是一模一样的题目，都是暂存一个左节点到temp中，然后互相交换 --> **合并二叉树**要自己构造一个新的二叉树 --> 求**一条路径的和是否和目标值相同**，用递归 --> **公共祖先**用左右递归,分为**普通二叉树的公共祖先**和**二叉搜索树的公共祖先** --> 二叉树**层序遍历** --> 二叉树**前中后序遍历(非递归)**



#### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

题解视频：[力扣官方](https://leetcode.cn/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode-solution/)

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            // size就是当队列的大小，也就是当前层的节点个数
            int size = queue.size(); 
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null){
                    queue.add(node.left);
                }
                if (node.right != null) {	
                    queue.add(node.right);
                }
                // 核心 别错写成i == queue.size()了
                if (i == size - 1) {
                    res.add(node.val);
                }
            }
        }
        return res;
    }
}
```

使用的是**BFS的广度优先遍历**，也就是层序遍历的思路，Tips：size就是当队列的大小，也就是当前层的节点个数，在遍历到每层队列的最后一个元素时，将其加入到结果集res中。



#### ==[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)==

```java
class Solution {

    int max = Integer.MIN_VALUE;

    public int diameterOfBinaryTree(TreeNode root) {
        getDepth(root);
        return max;
    }

    // 计算二叉树的深度
    private int getDepth(TreeNode root) {
        if (root == null) return 0;
        int left = getDepth(root.left);
        int right = getDepth(root.right);
        // left + right + 1表示所有的node节点数量，减1表示比如一共7个节点，经历6步，也就是直径是6
        max = Math.max(max, left + right + 1 - 1);
        return Math.max(left, right) + 1;
    }
}
```

[书森学院](https://www.bilibili.com/video/BV12L411V7Zf?spm_id_from=333.337.search-card.all.click)

**这题的直径指的是两个节点之间的间隔数**，比如题目所给的示例[4,2,1,3]，就是指的4个节点，但距离为3，也就是直径为3

在计算二叉树的深度那题的基础上发展而来的

为了理解其中的`left + right + 1 - 1`这句话，如图所示：可以理解为半径path的长度等于left长度加上right长度再加上root这个1，得到总的节点数，那么path长度等于总的节点数再减去1

<img src="http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220514154242964.png" alt="image-20220514154242964" style="zoom:50%;" />



#### [112. 路径总和](https://leetcode.cn/problems/path-sum/)

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) return false;
        if (root.left == null && root.right == null) {
            return (root.val - targetSum) == 0;
        }
        return hasPathSum(root.left, targetSum - root.val) 
        || hasPathSum(root.right, targetSum - root.val);
    }
}
```

**递归**



#### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return root;  
        TreeNode tmp = root.left;
        root.left = invertTree(root.right);
        root.right = invertTree(tmp); 
        return root;
    }
}
```

注意判空操作 和镜像二叉树是一个题目



#### ==[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)==

```java
class Solution {

    StringBuilder path = new StringBuilder();
    int res = 0;

    public int sumNumbers(TreeNode root) {
        dfs(root);
        return res;
    }

    private void dfs(TreeNode root) {
        if (root == null) return;
        path.append(root.val);
        if (root.left == null && root.right == null) {
            res += Integer.parseInt(path.toString());
        }
        dfs(root.left);
        dfs(root.right);
        //调用StringBuilder的API进行还原
        path.deleteCharAt(path.length() - 1);
    }
}
```

**回溯**

StringBuilder的这个API我不太熟悉：`path.deleteCharAt(path.length() - 1);`



#### [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<List<Integer>>();
        if (root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        // flag为true表示左到右遍历
        boolean flag = true;
        while (!queue.isEmpty()) {
            int size = queue.size();
            LinkedList<Integer> path = new LinkedList<>();
            for (int i =0; i < size; i++) {
                TreeNode node = queue.remove();
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
                if (flag) {
                    path.addLast(node.val);
                } else {
                    path.addFirst(node.val);
                }
            }
            flag = !flag;
            res.add(path);
        }
        return res;
    }
}
```

与层次遍历二叉树不同的地方见下面的标注

![image-20220527141742164](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220527141742164.png)



#### ==[124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)==

```java
class Solution {
    // 定义全局的最大值
    int res = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        if (root == null) return 0;
        dfs(root);
        return res;
    }

    private int dfs(TreeNode root) {
        if (root == null) return 0;
        int left = dfs(root.left);
        int right = dfs(root.right);
        // 取出root root+left root+right三者的最大值
        int tmp = Math.max(root.val, Math.max(root.val + left, root.val + right));
        // 如果有横跨root左右的话就再加入root + left + right 进行比较
        res = Math.max(res, Math.max(tmp, root.val + left + right));
        return tmp;
    }
}
```

最大路径分为4种情况：

1. root
2. root + left
3. root + right
4. left + root + right

为了防止全是负数的树，需要有一个**全局变量res**，初始值为Integer.MIN_VALUE

先求出前三者的max值，得到临时的max值为tmp，然后再将临时最大值tmp与第4个求出max值，并与res取出最后的max值，最后返回的时tmp，因为不是所有的情况都能横跨left + root + right三者的。



#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```java
class Solution {
    int res = 0;
    // 计数器
    int count = 0;
    public int kthLargest(TreeNode root, int k) {
        dfs(root, k);
        return res;
    }
	
    // 伪中序遍历（右根左）
    private void dfs(TreeNode root, int k) {
        if (root == null) return;
        // 右
        dfs(root.right, k);
        count++;
        if (count == k) {
            res = root.val; // 根
        }
        // 左
        dfs(root.left, k);
    }
}
```

什么是二叉搜索树 ？[题解](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/zui-jian-jie-yi-dong-de-dai-ma-tu-wen-bi-spxa/)

二叉搜索树是一棵有序的二叉树，所以我们也可以称它为二叉排序树。具有以下性质的二叉树我们称之为二叉搜索树：若它的左子树不为空，那么左子树上的所有值均小于它的根节点；若它的右子树不为空，那么右子树上所有值均大于它的根节点。它的左子树和右子树分别也为二叉搜索树。

**二叉搜索树的中序遍历是：左根右； 二叉搜索树的中序遍历从小到大是有序的。**

==**因此求二叉搜索树第k大的节点” 可转化为求 “二叉搜索树的中序遍历倒序的第k个节点”。**==

[视频题解](https://www.bilibili.com/video/BV1mE41137is?spm_id_from=333.337.search-card.all.click)

总之：**看到二叉搜索树，就要知道它的中序遍历是单调递增的**



#### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

```java
class Solution {
    List<String> res = new LinkedList<>();
    LinkedList<String> path = new LinkedList<>();

    public List<String> binaryTreePaths(TreeNode root) {
        if (root == null) return res;
        dfs(root);
        return res;
    }

    private void dfs(TreeNode root) {
        if (root == null) return;
        path.add(String.valueOf(root.val));
        // 到叶子节点返回
        if (root.left == null && root.right == null) {
            res.add(String.join("->", path));
        }
        // 利用前序遍历：根左右
        dfs(root.left);
        dfs(root.right);
        path.removeLast();
    }
}
```

[题解](https://leetcode.cn/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-java-by-su-vess/)

- 小技巧，使用了 `String.join()` 方法，为链表中的元素加入字符 `->` 。















## ==动态规划==

动态规划用于求最值的问题，比如最长公共子序列、最短编辑距离、最长递增子序列等

#### [剑指 Offer 10- I. 斐波那契数列](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)

```java
class Solution {
    public int fib(int n) {
        if(n == 0) return 0;
        int[] dp = new int[200];
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007;
        }
        return dp[n];
    }
}
```

初始化数组我用的是200这个长度，这个自己随便给，因为题目要求是n最多100，所以数组长度只要比100大，就都可以。

牛客不需要做 `if(n == 0) return 0;`判断，因为牛客的n是从1开始取的。

对于斐波那契的优化是面试经常问的：**空间优化**，即不用反复创建n个长度的数组，而是固定长度为3的数组。具体[参考值这个视频](https://www.bilibili.com/video/BV1664y1d7pi?spm_id_from=333.337.search-card.all.click&vd_source=35aeaee52b15e78b11967f5ef3ce655a)



#### [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

[**BM63** **跳台阶**](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=295&tqId=23261&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

牛客代码

```java
public class Solution {
    public int jumpFloor(int target) {
        int[] dp = new int[target + 2];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= target; i++) {
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
        }
        return dp[target];
    }
}
```

注意点：

* dp数组长度为 target + 2
* 遍历从2到target ，因为最后要返回dp[target]，所以要包含target 



#### [**BM64** **最小花费爬楼梯**](https://www.nowcoder.com/practice/6fe0302a058a4e4a834ee44af88435c7?tpId=295&tqId=2366451&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

```java
import java.util.*;

public class Solution {

    public int minCostClimbingStairs (int[] cost) {
        // write code here
        int length = cost.length;
        int[] dp = new int[length + 1];
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i <= length; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[length];
    }
}
```

[题解视频](https://www.bilibili.com/video/BV1cF411x7vY?spm_id_from=333.1007.top_right_bar_window_history.content.click)

助解图：

![image-20220402175125695](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220402175125695.png)





#### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

[牛客链接](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=295&tqId=23259&ru=%2Fpractice%2Fd8b6b4358f774294a89de2a6ac4d9337&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj)

[视频](https://www.bilibili.com/video/BV1SE411Q7MG?spm_id_from=333.880.my_history.page.click)  考察：动态规划，

动态规划步骤：

1. 明确dp[i]含义
2. 初始化dp[0]
3. 从i为1开始for循环遍历 更新dp[i]的含义

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

我经常会忘记定义res变量用来接收结果

方法二：

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = nums[0];
        int sum = 0;
        for (int num : nums) {
            // 如果 sum > 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字
            if (sum > 0) {
                sum += num;
            } else {
        // 如果sum <= 0，则说明sum对结果无增益效果，需要舍弃，则sum直接更新为当前遍历数字
                sum = num;
            }
            res = Math.max(res, sum);
        }
        return res;
    }
}
```



#### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

[视频](https://www.bilibili.com/video/BV14V411k7AK?spm_id_from=333.880.my_history.page.click) 考察：动态规划

[牛客链接](https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec?tpId=295&tqId=625&ru=%2Fpractice%2F459bd355da1549fa8a49e350bf3df484&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        // dp[i]数组表示以price[i]结尾的**最大利润**
        int[] dp = new int[n];
        dp[0] = 0;
        int buy = prices[0];
        // buy表示卖股票之前的某一天买入的价格，初始化为第一天，后期更新
        for (int i = 1; i < n; i++) {
            int sell = prices[i];
            // 获取此时股票的价格,prices数组为每天股票的价格
            int profit = sell - buy;
            // 如果这一天卖出，那么利润就是当天股票的价格减去之前购买的价格
            dp[i] = Math.max(dp[i - 1], profit);
            // 对比哪个利润更大
            buy = Math.min(buy, prices[i]);
            // 更新buy值，越小越好
            
        }
        // 只需返回dp数组的最后一个元素即可
        return dp[n - 1];
    }
}
```

简易版

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[] dp = new int[n]; // dp[i]数组表示以price[i]结尾的**最大利润**
        dp[0] = 0;
        int buy = prices[0]; //变量buy表示在哪天购买的股票,初始化为第一天，后期更新buy值为卖之前的最低值
        for (int i = 1; i < n; i++) {
            int profit = prices[i] - buy	;
            dp[i] = Math.max(dp[i - 1], profit);
            buy = Math.min(buy, prices[i]);
        }
        return dp[n - 1];
    }
}
```

#### [**BM80** **买卖股票的最好时机(一)**](https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec?tpId=295&tqId=625&ru=%2Fpractice%2F6fe0302a058a4e4a834ee44af88435c7&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj)

今天（2022-4-2）看跑[马拉松的程序员](https://www.bilibili.com/video/BV1EF41147hr?spm_id_from=333.1007.top_right_bar_window_history.content.click)的视频发现这个解法对于买卖股票最佳时间第一种的题目解法最好

```java
import java.util.*;

public class Solution {
    public int maxProfit (int[] prices) {
        int length = prices.length;
        if (length < 2) return 0;
        // 本题思想就是：最高价值 = 当前价格 - 之前某个最低价格(最低价格时刻更新)
        // 默认最低价值为第一天价格，后期更新
        int minValue = prices[0];
        // maxValue取-1，-100都不合适，故取int的最小值
        int maxValue = Integer.MIN_VALUE;
        for (int i = 1; i < length; i++) {
            // 时刻更新最低值，当i对应的value比原定的prices[0]小的时侯，那就取而代之
            minValue = Math.min(minValue, prices[i]);
            // 计算出最大价值
            maxValue = Math.max(prices[i] - minValue, maxValue);
        }
        return maxValue;
    }
}
```

本解法核心思想就是：最高价值 = 当前价格 - 之前某个最低价格(最低价格时刻更新)



#### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

先用最朴素的解法：

```java
class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1]) {
                max += (prices[i] - prices[i - 1]);
            }
        }
        return max;
    }
}
```

下面再用动态规划的思路：

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][] dp = new int[len][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[len - 1][0];
    }
}
```

[参考题解](https://www.bilibili.com/video/BV1Ri4y1k7K4?spm_id_from=333.337.search-card.all.click)

明确一下`dp[i][j]`的含义，其中j只取0和1，0代表未持有股票，1代表持有股票。所以`dp[i][0]` 代表第i天不持有股票；而`dp[i][1]`代表第i天持有股票





#### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int res = 1;
        for (int i = 0; i < nums.length; i++) {
            dp[i] = 1; // 因为任意一个数字开头，最不利也是1
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            res = Math.max(res, dp[i]);            
        }
        return res;
    }
}
```

[参考题解视频](https://www.bilibili.com/video/BV19b4y1R7K3?spm_id_from=333.337.search-card.all.click)，当然我的答案没完全按照它的来



#### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

子序列就是可以不连续，但子串是要连续的

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        // 初始化
        dp[0][0] = 0;
        for (int i = 1; i < m; i++) {
            dp[i][0] = 0;
        }
        for (int j = 1; j < n; j++) {
            dp[0][j] = 0;
        }
        // 状态转移
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
}
```

初始化为什么要是`int[][] dp = new int[m + 1][n + 1];`呢？因为如下图，为了后面i-1和j-1的操作越界，所以将第一行和第一列都初始化为0，所以就比原先的多了一行一列

为什么判断`text1.charAt(i - 1) == text2.charAt(j - 1)`?因为i是从1开始遍历的到i等于m，所以相当于还是从0开始，到m-1，所以这里面的i - 1和j - 1 其实相当于就是i和j

![image-20220515142818942](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220515142818942.png)

![image-20220529232217172](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220529232217172.png)



#### [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int res = 0;
        int[][] dp = new int[m + 1][n + 1];
        // 初始化
        dp[0][0] = 0;
        for (int i = 1; i < m + 1; i++) {
            dp[i][0] = 0;
        }
        for (int j = 1; j < n + 1; j++) {
            dp[0][j] = 0;
        }
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = 0;
                }
                res = Math.max(res, dp[i][j]);
            }
        }
        return res;
    }
}
```

**动态规划**

![image-20220516202005472](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220516202005472.png)

这题不用对二维数组初始话也行，如下：

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int res = 0;
        int[][] dp = new int[m + 1][n + 1];
        // 初始化
        dp[0][0] = 0;
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = 0;
                }
                res = Math.max(res, dp[i][j]);
            }
        }
        return res;
    }
}
```





#### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m + 1][n + 1];
        // 初始化
        dp[0][0]  = 0;
        // 不重复初始化，i和j都从1开始
        for (int i = 1; i < m + 1; i++) {
            dp[i][0] = i;
        }
        for (int j = 1; j < n + 1; j++) {
            dp[0][j] = j;
        }
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
            } 
        }
        return dp[m][n];
    }
}
```

[题解](https://leetcode.cn/problems/edit-distance/solution/bian-ji-ju-chi-by-chen-wei-f-oy3i/)

`dp[i][j]`到前一步分为如下四种情况：**1. 不用操作；1. 删除操作；3. 增加操作；4. 替换操作**

![image-20220514112530737](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220514112530737.png)

![image-20220514112308818](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220514112308818.png)

#### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

![img](http://milessg.oss-cn-beijing.aliyuncs.com/img/robot_maze.png)



``` java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

为什么返回`dp[m - 1][n - 1]`,而不是`dp[m][n]`

举个例子：int[4]长度为4，下标是0-3，`dp[m][n]`就越界了



#### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

![img](http://milessg.oss-cn-beijing.aliyuncs.com/img/robot1.jpg)

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];
        // 初始化第一行、第二行、第m - 1行...
        for (int i = 0; i < m; i++) {
            // 跳过障碍物
            if (obstacleGrid[i][0] == 1) {
                break;
            }
            dp[i][0] = 1;
        }
        // 初始化第一列、第二列、第n - 1列...
        for (int i = 0; i < n; i++) {
            // 跳过障碍物
            if (obstacleGrid[0][i] == 1) {
                break;
            }
            dp[0][i] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                // 跳过障碍物
                if (obstacleGrid[i][j] == 1) {
                    continue;
                }
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```





#### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        // 初始化dp[0][0]要注意不是0，而是grid[0][0]
        dp[0][0] = grid[0][0];
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < n; j++){
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }     
        // 状态转移
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

[参考题解见这个网页的最后](https://labuladong.github.io/algo/3/26/84/)



#### 打家劫舍专题（2题）

#### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

```java
class Solution {
    public int rob(int[] nums) {
        if (nums.length <= 1) return (nums.length == 0) ? 0 : nums[0];
        int res = Math.max(nums[0], nums[1]);
        // dp[i]表示截至第i家为止，能够拿到的最大的钱数
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

#### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

和上一题的区别是这题是**带环**的，即首位相连的，所以将其分为三种情况讨论，分好类以后，进行和第一题一模一样的操作

````java
class Solution {
    public int rob(int[] nums) {
        /*
        情况分类：
            1. 不抢头，不强尾
            2. 抢头，不强尾
            3. 不抢头，抢尾
        */
        if (nums.length <= 1) return (nums.length == 0) ? 0 : nums[0];
        // 1. 不抢头，不强尾
        int[] nums1 = Arrays.copyOfRange(nums, 1, nums.length - 1);
        // 2. 抢头，不强尾
        int[] nums2 = Arrays.copyOfRange(nums, 0, nums.length - 1);
        // 3. 不抢头，抢尾
        int[] nums3 = Arrays.copyOfRange(nums, 1, nums.length);

        return Math.max(Math.max(help(nums1),help(nums2)),help(nums3));
    }

    // 下面就是纯纯复刻打家劫舍第一题的代码了
    private int help(int[] nums) {
        if (nums.length <= 1) return (nums.length == 0) ? 0 : nums[0];
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        int res = Math.max(nums[0], nums[1]); // 最终结果
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
````

**Arrays.copyOfRange() 方法用于复制，左闭右开**



#### 01背包问题

题目描述：

![image-20220515230313622](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220515230313622.png)

**==明确`dp[i][w]`的含义是关键==**

![image-20220515230538280](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220515230538280.png)

状态转移分为两种：放第i个物品和不放第i个物品

![image-20220515231216574](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220515231216574.png)

![image-20220515231415527](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220515231415527.png)

由于数组索引从 0 开始，而我们定义中的 `i` 是从 1 开始计数的，所以 `val[i-1]` 和 `wt[i-1]` 表示第 `i` 个物品的价值和重量。你如果选择将第 `i` 个物品装进背包，那么第 `i` 个物品的价值 `val[i-1]` 肯定就到手了，接下来你就要在剩余容量 `w - wt[i-1]` 的限制下，在前 `i - 1` 个物品中挑选，求最大价值，即 `dp[i-1][w - wt[i-1]]`。

最后注意处理了 `w - wt[i-1]` 可能小于 0 导致数组索引越界的问题



#### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp  = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE / 2);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                // 只有金钱总数i大于等于金币面值1、2、5才进行dp
                if (coins[j] <= i) {
                    // 比如dp[i]为11元，那么dp[i - coins[i]]就等于10或9或者6，这三个都是只要加一个硬币就能得到11
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }  
            }
        }
        return (dp[amount] == Integer.MAX_VALUE / 2) ? -1 : dp[amount];
    }
}
```



#### [221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int max = 0;
        int m = matrix.length;
        int n = matrix[0].length;
        if (matrix == null || m == 0 || n == 0) {
            return max;
        }
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
                    }
                    max = Math.max(max, dp[i][j]);
                }
            }
        }
        return max * max;
    }
}
/**
    dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为: 
    dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);
**/
```





















2022-3-29

## ==回溯算法==

**回溯算法的本质就是遍历一个多叉树的过程**

![image-20220514184908041](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220514184908041.png)

![image-20220515164542629](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220515164542629.png)

#### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

[牛客链接](https://www.nowcoder.com/practice/c9addb265cdf4cdd92c092c655d164ca?tpId=295&tqId=725&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

```java
// 参考题解：https://www.bilibili.com/video/BV1th411x7tS?from=search&seid=10007827490753236006&spm_id_from=333.337.0.0
class Solution {
    
    private List<String> pathList = new LinkedList<>();
    private int maxPairCount; // 最大能够匹配的括号组数
    
    public List<String> generateParenthesis(int n) {
        maxPairCount = n;
        backTracking("", 0, 0);
        return pathList;
    }
    
    private void backTracking(String path, int leftCount, int rightCount) {
        if (path.length() == maxPairCount * 2) {
            pathList.add(path);
            return;
        }
        // 如果左括号数量小于n，则表示还可以添加左括号，进行回溯
        if (leftCount < maxPairCount) {
            backTracking(path + "(", leftCount + 1, rightCount);
        }
        // 如果右括号的数量小于左括号，才可以添加右括号
        if (rightCount < leftCount) {
            backTracking(path + ")", leftCount, rightCount + 1);
        }
    }
}
```



#### [78. 子集](https://leetcode.cn/problems/subsets/)

**子集（元素无重、不可复选）**

比如输入`nums = [1, 2, 3]` 输出 `[ [],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3] ]`

```java
class Solution {

    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> path = new LinkedList<Integer>();

    public List<List<Integer>> subsets(int[] nums) {
        if (nums.length == 0) return res;
        dfs(nums, 0);
        return res;
    }
	
    // start相当于树的层数
    private void dfs(int[] nums, int start) {
        res.add(new LinkedList<>(path));
        //这个终止条件可不加
        if (start >= nums.length) {
            return;
        }
        for (int i = start; i < nums.length; i++) {
            path.add(nums[i]);
            // 这里是i + 1，而不是start + 1的原因：那么start它相当于是一个固定的值0，			// 而i是每次循环都更新的
            dfs(nums, i + 1);
            path.removeLast();
        }
    }
}
```



#### [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

**子集/组合（元素可重、不可复选）**

比如输入 `nums = [1,2,2]`，你应该输出：

```java
[ [],[1],[2],[1,2],[2,2],[1,2,2] ]
```

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        if (nums == null) return res;
        // 先排序，让相同的元素靠在一起
        Arrays.sort(nums);
        dfs(nums, 0);
        return res;
    }

    private void dfs(int[] nums, int start) {
        // 前序位置，每个节点的值都是一个子集
        res.add(new LinkedList<>(path));
        // 可省略
        if (start >= nums.length) {
            return;
        }
        for (int i = start; i < nums.length; i++) {
            // 剪枝逻辑，值相同的相邻树枝，只遍历第一条
            if (i > start && nums[i] == nums[i - 1]) {
                continue;
            }
            path.add(nums[i]);
            dfs(nums, i + 1);
            path.removeLast();
        }
    }
}
```



#### [46. 全排列](https://leetcode.cn/problems/permutations/)

#### [**BM55** **没有重复项数字的全排列**](https://www.nowcoder.com/practice/4bcf3081067a4d028f95acee3ddcd2b1?tpId=295&tqId=701&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

**排列（元素无重、不可复选）**

比如输入 `nums = [1,2,3]` 函数的返回值应该是：

```java
[
    [1,2,3],[1,3,2],
    [2,1,3],[2,3,1],
    [3,1,2],[3,2,1]
]
```

```java
class Solution {

    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> permute(int[] nums) {
        dfs(nums, 0);
        return res;
    }

    private void dfs(int[] nums, int start) {
        if (path.size() == nums.length) {
            res.add(new LinkedList(path));
        }
        for (int i = start ; i < nums.length; i++) {
            // 排除已经加进res的元素
            if (path.contains(nums[i])) {
                continue;
            }
            path.add(nums[i]);
            // 这个是唯一从start，不是i开始遍历的地方，因为它是全排列，每次都要从0开始
            dfs(nums, start);
            path.removeLast();
        }
    }
}
```

[参考题解](https://www.bilibili.com/video/BV1P5411N7Xc?spm_id_from=333.337.search-card.all.click) 注意dfs的方法不要传入泛型List而是要传入具体的LinkedList，然后要使用removeLast方法来减枝



#### [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)

**排列（元素可重、不可复选）**

比如输入 `nums = [1,2,2]`，函数返回：

```java
[ [1,2,2],[2,1,2],[2,2,1] ]
```

```java
class Solution {

    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> path = new LinkedList<>();
    boolean[] used;

public List<List<Integer>> permuteUnique(int[] nums) {
    // 先排序，让相同的元素靠在一起
    Arrays.sort(nums);
    used = new boolean[nums.length];
    dfs(nums);
    return res;
}

    private void dfs(int[] nums) {
        if (path.size() == nums.length) {
            res.add(new LinkedList(path));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }
            // 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            path.add(nums[i]);
            used[i] = true;
            dfs(nums);
            path.removeLast();
            used[i] = false;
        }
    }
}
```



#### [77. 组合](https://leetcode.cn/problems/combinations/)

**组合（元素无重、不可复选）**

比如输入`combine(3, 2)` 输出`[ [1,2],[1,3],[2,3] ]`

```java
class Solution {

    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> combine(int n, int k) {
        // dfs里面第三个变量从1开始，比如：取从[1, n]中长度为k的组合
        dfs(n, k, 1);
        return res;
    }

    private void dfs(int n, int k, int start) {
        if (path.size() == k) {
            res.add(new LinkedList<>(path));
        }
        for (int i = start; i <= n; i++) {
            path.add(i);
            dfs(n, k, i + 1);
            path.removeLast();
        }
    }
}
```



#### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

**组合（元素无重、可复选）**

比如输入 `candidates = [1,2,3], target = 3`，算法应该返回：

```
[ [1,1,1],[1,2],[3] ]
```

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        dfs(candidates, target, 0);
        return res;
    }

    public void dfs(int[] candidates, int target, int start) {
        // 这个可以不加，仅用于优化，见下图
        if (target < 0) return;
        if (target == 0) {
            res.add(new LinkedList(path));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            if (candidates[i] <= target) {
                path.add(candidates[i]);
                // 因为可以重复使用，所以还是i，比如虽然只有一个2，但可以用几次
                dfs(candidates, target - candidates[i], i);
                path.remove(path.size() - 1); //回溯，恢复现场
            }
        }
    }
}

```

[题解](https://leetcode.cn/problems/combination-sum/solution/hui-su-suan-fa-zui-tong-su-yi-dong-de-da-6qyl/)

![在这里插入图片描述](http://milessg.oss-cn-beijing.aliyuncs.com/img/1627472171-LvIkcD-file_1627472171400)



#### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

![image-20220618212753659](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220618212753659.png)

```java
class Solution {

    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        if (candidates == null) return res;
        // 关键
        Arrays.sort(candidates);
        dfs(candidates, target, 0);
        return res;
    }

    private void dfs(int[] candidates, int target, int  start) {
        if (target == 0) {
            res.add(new LinkedList<>(path));
        }
        // 注意
        if (target < 0) return;
        for (int i = start; i < candidates.length; i++) {
            if (i > start && candidates[i - 1] == candidates[i]) {
                continue;
            }
            path.add(candidates[i]);
            dfs(candidates, target - candidates[i], i + 1);
            path.removeLast();
        }
    }
}
```

和39题的区别是40题的元素可以使用多次，所以是dfs的时候需要 i+1且还要进行去重操作



#### 路径和专题

#### [112. 路径总和](https://leetcode.cn/problems/path-sum/)

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) return false;
        if (root.left == null && root.right == null) {
            return (targetSum - root.val) == 0;
        }
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
    }
}
```

**递归**



#### [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

```java
class Solution {

    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if (root == null) return res;
        dfs(root, new LinkedList<>(), targetSum);
        return res;
    }

    private void dfs(TreeNode node, LinkedList path, int sum) {
        if (node == null) return;
        path.add(node.val);// 将节点加入列表
        if (node.left == null && node.right == null && node.val == sum) {
            res.add(new LinkedList<>(path));// 满足条件就加入结果集
            path.removeLast();// 还原
            return;
        }
        dfs(node.left, path, sum - node.val);
        dfs(node.right, path, sum - node.val);
        path.removeLast();// 还原
    }
}
```

回溯，[参考题解](https://www.bilibili.com/video/BV1wY411L7qq?spm_id_from=333.337.search-card.all.click)



#### [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

```java
class Solution {

    StringBuilder path = new StringBuilder();
    int res = 0;

    public int sumNumbers(TreeNode root) {
        dfs(root);
        return res;
    }

    private void dfs(TreeNode root) {
        if (root == null) return;
        path.append(root.val);
        if (root.left == null && root.right == null) {
            res += Integer.parseInt(path.toString());
        }
        dfs(root.left);
        dfs(root.right);
        //调用StringBuilder的API进行还原
        path.deleteCharAt(path.length() - 1);
    }
}
```

**回溯**

StringBuilder的这个API我不太熟悉：`path.deleteCharAt(path.length() - 1);`

#### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

```java
class Solution {
    List<String> res = new LinkedList<>();
    LinkedList<String> path = new LinkedList<>();

    public List<String> binaryTreePaths(TreeNode root) {
        if (root == null) return res;
        dfs(root);
        return res;
    }

    private void dfs(TreeNode root) {
        if (root == null) return;
        path.add(String.valueOf(root.val));
        // 到叶子节点返回
        if (root.left == null && root.right == null) {
            res.add(String.join("->", path));
        }
        // 利用前序遍历：根左右
        dfs(root.left);
        dfs(root.right);
        path.removeLast();
    }
}
```

[题解](https://leetcode.cn/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-java-by-su-vess/)

- 小技巧，使用了 `String.join()` 方法，为链表中的元素加入字符 `->` 。





## ==字符串==

#### [415. 字符串相加](https://leetcode.cn/problems/add-strings/)

[K神题解](https://leetcode-cn.com/problems/add-strings/solution/add-strings-shuang-zhi-zhen-fa-by-jyd/)

```java
class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder res = new StringBuilder();
        int i = num1.length() - 1;
        int j = num2.length() - 1;
        int carry = 0;
        while (i >= 0 || j >= 0) {
            int n1 = (i >= 0) ? num1.charAt(i) - '0' : 0;
            int n2 = (j >= 0) ? num2.charAt(j) - '0' : 0;
            // 比如说tem是13
            int tmp = n1 + n2 + carry;
            // 那么carry就是1
            carry = tmp / 10;
            // 再append一个3
            res.append(tmp % 10);
            i--;
            j--;
        }
        if (carry == 1) {
            res.append(1);
        }
        return res.reverse().toString();
    }
}
```

[题解](https://leetcode-cn.com/problems/add-strings/solution/add-strings-shuang-zhi-zhen-fa-by-jyd/)



#### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode slow = head;
        ListNode fast = head;
        // fast快指针先向右移动n步
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }
        // 这个不要忘记判断
        if (fast == null) return head.next;
        while (fast.next != null) {
            slow = slow.next;
            fast = fast.next;
        }
        slow.next = slow.next.next;
        return head;
    }
}
```

经常忘记这个判断导致空指针异常 `if(fast == null) return head.next;`

牛客链接如下：

[**BM9** **删除链表的倒数第n个节点**](https://www.nowcoder.com/practice/f95dcdafbde44b22a6d741baf71653f6?tpId=295&tqId=727&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

```java
import java.util.*;

public class Solution {
    public ListNode removeNthFromEnd (ListNode head, int n) {
        // write code here
        ListNode fast = head, slow = head;
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }
        if(fast == null) return head.next; // 这个不要忘记判断
        while (fast.next != null) {
            slow = slow.next;
            fast = fast.next;
        }
        slow.next = slow.next.next;
        return head;
    }
}
```



#### ==[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)==

[牛客链接](https://www.nowcoder.com/practice/b4525d1d84934cf280439aeecc36f4af?tpId=295&tqId=25269&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

[参考视频](https://www.bilibili.com/video/BV1Qv411n7bd?spm_id_from=333.1007.top_right_bar_window_history.content.click)

**双指针法**

```java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 2) {
            return s;
        }
        int maxLen = 1;
        int startIndex = 0;
        for (int i = 1; i < s.length(); i++) {
            int left = i - 1;
            int right = i + 1;
            int curLen = 1;
            while (left >= 0 && s.charAt(left) == s.charAt(i)) {
                left--;
                curLen++;
            }
            while (right <= s.length() - 1 && s.charAt(i) == s.charAt(right)) {
                right++;
                curLen++;
            }
            // 至此，已经找出来与中间某一个字符左右相同的所有子区间，
            // 如abccccbba就已经把所有的c即cccc都找出来了
            while (left >= 0 && right <= s.length() - 1 && s.charAt(left) == s.charAt(right)) {
                left--;
                right++;
                curLen += 2;
            }
            // 为什么还要这么一个判断？ 因为很多字符串并不一定就存在连续的回文子串
            if (curLen > maxLen) {
                maxLen = curLen;
                startIndex = left + 1;
            }
        }
        return s.substring(startIndex, startIndex + maxLen);
    }
}
```

本题比较有难度，**思路就是先找出某中间数，把这个中间数的左右相等的值都找出来**，比如找abccccbba的某个中间数c，利用双指针先把所有的cccc先找出来，**然后双指针继续分别向左和向右进行遍历，找出所有的对等相等的值**，这题比较容易弄错的就是substring的左右指针究竟是哪一个，要仔细确定还有就是初始定义的长度maxSubStrLength和中途确定的currentLength二者如果不进行比较的话，就可能出现万一没有像连续的某一个中间值的话，就会出现maxSubStrLength反倒大于currentLength的情况。

牛客的答案

```java
import java.util.*;

public class Solution {

    public int getLongestPalindrome (String A) {
        // write code here
        return getPalindrome(A).length();
        
    }
    
    private String getPalindrome(String s) {
        if (s == null || s.length() < 2) return s;
        int maxLength = 1;
        int startIndex = 0;
        for (int i = 0; i < s.length(); i++) {
            int left = i - 1;
            int right = i + 1;
            int currentLength = 1;
            while (left >= 0 && s.charAt(i) == s.charAt(left)) {
                left--;
                currentLength++;
            }
            while (right <= s.length() - 1 && s.charAt(i) == s.charAt(right)) {
                right++;
                currentLength++;
            }
            while (left >= 0 && right <= s.length() - 1 
                   && s.charAt(left) == s.charAt(right)) {
                left--;
                right++;
                currentLength += 2;
            }
            if (currentLength > maxLength){
                maxLength = currentLength;
                startIndex = left + 1;
            }
        }
        return s.substring(startIndex, startIndex + maxLength);
    }
}
```

多写 多练 都能记住

牛客总是要和力扣做的不完全一样，所以就返回int咯，不过一个length()就可以搞定咯



#### [**BM91** **反转字符串**](https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3?tpId=295&tqId=1024337&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

双指针重拳出击

```java
import java.util.*;

public class Solution {
    public String solve (String str) {
        // write code here
        char[] chars = str.toCharArray();
        int left = 0, right = chars.length - 1;
        while (left <= right) {
            char temp = chars[right];
            chars[right] = chars[left];
            chars[left] = temp;
            left++;
            right--;
        }
        return new String(chars);
    }
}
```

注意最后返回的是`return new String(chars);`,是`String(char[] chars)`的构造器



#### [151. 颠倒字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

```java
class Solution {
    public String reverseWords(String s) {
       StringBuilder res = new StringBuilder();
       String[] strs = s.trim().split(" ");
       for (int i = strs.length - 1; i >= 0; i--) {
           if (strs[i].equals("")) {
               continue;
           }
           res.append(strs[i] + " ");
       }
       return res.toString().trim();
    }
}
```

最后继续trim()一下，很妙，因为每次添加strs[i]的时候都加上一个空格，所以最后那个也自带空格，所以要trim()





## ==链表==

#### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

#### [**BM8** **链表中倒数最后k个结点**](https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=295&tqId=1377477&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

```java
import java.util.*;

public class Solution {
   public ListNode FindKthToTail (ListNode head, int k) {
        ListNode slow = head;
        ListNode fast = head;
        for (int i = 0; i < k; i++) {
            if (fast == null) {
                return null;
            }
            fast = fast.next;
        }
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

这道题属于简单题，但是我在提交过程中有几个样例过不了，检查发现是在将fast节点右移k位时，没有注意到要判断fast为空的情况，**如果fast为空，要返回null，否在会出现空指针异常**，**另外右移记住用for循环右移，经常忘记。**



#### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode cur = head;
        Stack<Integer> stack = new Stack<>();
        while (head != null) {
            stack.push(head.val);
            head = head.next;
        }
        while (cur != null) {
            if (stack.pop() != cur.val) return false;
            cur = cur.next;
        }
        return true;
    }
}
```

**回文链表**这道题就是我所说的**很少有的用栈数据结构做的链表的题目**



#### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

#### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)（和141的区别就是返回值不同，都做HashSet做好理解）

[牛客链接](https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=295&tqId=605&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

方法一：HashSet去重、开辟额外空间 、单指针

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        HashSet<ListNode> set = new HashSet<>();
        ListNode cur = head;
        while (cur != null) {
            if (set.contains(cur)) {
                return true;
            } else {
                set.add(cur);
            }
            cur = cur.next;
        }
        return false;
    }
}
```

方法二：定义快慢双指针、双指针

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
}
```



#### [**BM15** **删除有序链表中重复的元素-I**](https://www.nowcoder.com/practice/c087914fae584da886a0091e877f2c79?tpId=295&tqId=664&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

```java
import java.util.*;

public class Solution {

    public ListNode deleteDuplicates (ListNode head) {
        HashSet<Integer> set = new HashSet<Integer>();
        ListNode dump = new ListNode(-1);  //创建一节点指向头节点 方便删除节点
        dump.next = head;
        while(dump.next != null){
            if(set.contains(dump.next.val)){
                dump.next = dump.next.next;
            } else {
                set.add(dump.next.val);
                dump = dump.next;
            }
        }
        return head;
    }
}
```

设置开头的**dummy**，防止只有1个节点的情况没法删除



#### [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return null;
        ListNode cur = head;
        while (cur.next != null) {
            if (cur.val == cur.next.val) {
                cur.next = cur.next.next;
            } else {
                cur = cur.next;
            }
        }
        return head;
    }
}
```

重复元素删除一个即可



#### [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode cur = dummy;
        while (cur.next != null) {
            ListNode tmp = cur.next;
            if (tmp.next == null || tmp.val != tmp.next.val) {
                cur = cur.next;
            } else {
                while (tmp.next != null && tmp.val == tmp.next.val) {
                    tmp.next = tmp.next.next;
                }
                cur.next = tmp.next;
            }
        }
        return dummy.next;
    }
}
```

**重复元素全部删除**

方法二：HashMap（好理解，记这种）

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        Map<Integer, Integer> map = new HashMap<>();
        ListNode cur = head;
        while (cur != null) {
            if (map.containsKey(cur.val)) {
                map.put(cur.val, map.get(cur.val) + 1);
            } else {
                map.put(cur.val, 1);
            }
            cur = cur.next;
        }
        ListNode dummy = new ListNode(-1);
        ListNode tmp = dummy;
        cur = head;
        while (cur != null) {
            if (map.get(cur.val) == 1) {
                // 从map中获得到唯一元素的话，就直接构造新的节点进行连接
                tmp.next = new ListNode(cur.val);
                tmp = tmp.next;
            }
            // cur是无论如何都要移动的
            cur = cur.next;
        }
        return dummy.next;
    }
}

```



#### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head;
        ListNode pre = null;
        while (cur != null) {
            ListNode tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
```



#### [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode pre = dummy;
        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }

        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        ListNode rightNode = pre;
        for (int i = 0; i < right - left + 1; i++) {
            rightNode = rightNode.next;
        }

        // 第 3 步：切断出一个子链表（截取链表）
        // leftNode就是图中黄色部分的第一个元素；rightNode就是图中黄色元素的最后一个
        // curr就是如图所示的rightNode的下一个元素
        ListNode leftNode = pre.next;
        ListNode curr = rightNode.next;

        // 注意：切断链接
        pre.next = null;
        rightNode.next = null;

        // 第 4 步：同第 206 题，反转链表的子区间
        reverse(leftNode);

        // 第 5 步：接回到原来的链表中
        pre.next = rightNode;
        leftNode.next = curr;
        return dummy.next;
    }

    // 206. 反转链表（但没有返回值）
    public void reverse(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
    }
}
```

题解来源对[官方题解](https://leetcode.cn/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/)的改编

使用「206. 反转链表」的解法，反转 left 到 right 部分以后，再拼接起来。我们还需要记录 left 的前一个节点，和 right 的后一个节点。如图所示：**pre是前驱节点，curr是后驱节点**

![image-20220623135556439](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220623135556439.png)

算法步骤：

第 1 步：先将待反转的区域反转；
第 2 步：把 pre 的 next 指针指向反转以后的链表头节点，把反转以后的链表的尾节点的 next 指针指向 succ。



#### [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummyHead = new ListNode(-1);
        dummyHead.next = head;
        ListNode curr = dummyHead;
        while (curr.next != null) {
            ListNode next = curr.next;
            if (next.next == null || next.val != next.next.val) {
                curr = curr.next;
            } else {
                while (next.next != null && next.val == next.next.val) {
                    next.next = next.next.next;
                }
                curr.next = next.next;
            }
        }
        return dummyHead.next;
    }
}
```



#### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

```java
public class Solution {
    public boolean isPail (ListNode head) {
        ListNode tmp = head;
        Stack<ListNode> stack = new Stack<>();
        while (tmp != null) {
            stack.push(tmp);
            tmp = tmp.next;
        }
        // 将tmp重新指向首节点
        tmp = head;
        while (!stack.isEmpty()) {
            if (stack.pop().val != tmp.val) {
                return false;
            }
            tmp = tmp.next;
        }
        return true;
    }
}
```

**栈**



#### [**链表相加(二)**](https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=295&tqId=1008772&ru=%2Fpractice%2F6ab1d9a29e88450685099d45c9e31e46&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295)

```java
import java.util.*;

public class Solution {
    public ListNode addInList (ListNode head1, ListNode head2) {
        if (head1 == null || head2 == null) {
            return (head1 == null) ? head2 : head1;
        }
        head1 = reverse(head1);
        head2 = reverse(head2);
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;
        // 进位
        int carry = 0;
        while(head1 != null || head2 != null || carry != 0) {
            int val1 = (head1 == null) ? 0 : head1.val;
            int val2 = (head2 == null) ? 0 : head2.val;
            int tmp = val1 + val2 + carry;
            // 获取进位
            carry = tmp / 10;
            tmp %= 10;
            cur.next = new ListNode(tmp);
            cur = cur.next;
            if (head1 != null) {
                head1 = head1.next;
            }
            if (head2 != null) {
                head2 = head2.next;
            }
        }
        return reverse(dummy.next);
    }
    
    // 206反转链表
    private ListNode reverse(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
```



#### [148. 排序链表](https://leetcode.cn/problems/sort-list/)

```java
class Solution {
    public ListNode sortList(ListNode head) {
        return sort(head, null);
    }

    // 将start到end开始旋转
    private ListNode sort(ListNode start, ListNode end) {
        if (start == end) {
            return start;
        }
        ListNode fast = start;
        ListNode slow = start;
        // slow移动到中部，fast移动到尾部
        while (fast != end && fast.next != end) {
            fast = fast.next.next;
            slow = slow.next;
        }
        // 旋转后半段，定义为l2
        ListNode l2 = sort(slow.next, end);
        // 将已经旋转过的后半段l2断开
        slow.next = null;
        ListNode l1 = sort(start, slow);
        return merge(l1, l2);
    }

    // 21. 合并两个有序链表
    private ListNode merge(ListNode l1, ListNode l2) {
        if (l1 == null || l2 == null) {
            return (l1 == null) ? l2 : l1;
        }
        if (l1.val < l2.val) {
            l1.next = merge(l1.next, l2);
            return l1;
        } else {
            l2.next = merge(l1, l2.next);
            return l2;
        }
    }
}
```

[郭郭wg](https://leetcode.cn/problems/sort-list/solution/cpp-gui-bing-pai-xu-si-lu-qing-xi-dai-ma-x8kr/)



## ==**栈/队列**==

#### [剑指 Offer 09. 用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```java
class CQueue {

    Stack<Integer> stack1;
    Stack<Integer> stack2;

    public CQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    
    public void appendTail(int value) {
        stack1.push(value);
    }
    
    public int deleteHead() {
        // 将先加进来的删除
        if (!stack2.isEmpty()) {
            // 辅助栈如果不为空，将其栈顶元素弹出即可
            return stack2.pop();
        }
        if (stack1.isEmpty() && stack2.isEmpty()){
            // 根据题意，都为空返回-1，辅助栈为空，且原来的栈也为空
            return -1;
        }
        while (!stack1.isEmpty()) {
            // 原来的栈不为空，将其加入到辅助栈中
            stack2.push(stack1.pop());
        }

        //返回辅助栈的栈顶元素
        return stack2.pop();
    }
}
```

[牛客链接](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=295&tqId=23281&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        // 将栈1倒叙添加到栈2中
        while (!stack1.isEmpty()) {
            stack2.push(stack1.pop());
        }
        int res = stack2.pop(); // 这个res就是要pop出去的结果
        // 这个操作是为了以后仍可以再次pop，所以每次pop()方法执行玩，都恢复原有的序列
        while (!stack2.isEmpty()) {
            stack1.push(stack2.pop());
        }
        return res;
    }
}
```

!!! 注意，力扣实现的是push和delete操作，牛客实现的是push和pop操作，相当于加起来一共三个方法，都要掌握。

对于pop()方法的说明：

* 执行pop操作时，先把stack1的数字全部pop出来，并push到stack2中去，最后一个从stack1中pop出的数字，即是第一个从stack2中pop出来的数字，就是我们最先push入stack1的数字，返回该数字；重点在于：**为了实现了先进先出的原则，且不影响后续的操作，我们在执行pop操作时只要求输出一个数字，其他的不变；所以又要把所有的存在stack2的数字全部pop出来再push到stack1中去，等待下一次pop，或者push操作。** 



#### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

```java
class MyQueue {

    Stack<Integer> inStack;
    Stack<Integer> outStack;

    public MyQueue() {
        inStack = new Stack<>();
        outStack = new Stack<>();
    }
    
    public void push(int x) {
        inStack.push(x);
    }
    
    // 从outStack pop出来
    public int pop() {
        while (outStack.isEmpty()) {
            in2out();
        }
        return outStack.pop();
    }
    
    public int peek() {
        while (outStack.isEmpty()) {
            in2out();
        }
        return outStack.peek();
    }
    
    public boolean empty() {
        return inStack.isEmpty() && outStack.isEmpty();
    }

    private void in2out() {
        while (!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
    }
}
```





#### [剑指 Offer 30. 包含min函数的栈](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)

#### [**BM43** **包含min函数的栈**](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=295&tqId=23268&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

##### 方法一：小顶堆 + 栈 （好理解）

```java
class MinStack {
    
    // 用优先队列构建小顶堆，堆顶元素即为最小的元素
    PriorityQueue<Integer> queue= new PriorityQueue<>(); 
    // 栈
    Stack<Integer> stack;
    
    public MinStack() {
        stack = new Stack<>();
    }
    
    public void push(int x) {
        stack.push(x);
        queue.add(x); // 优先队列queue的堆顶一定是minshu
    }
    
    public void pop() {
        queue.remove(stack.pop());
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return queue.peek();
    }
}
```

注意一下：上面的代码：前几行可以改成：

```java
    Stack<Integer> stack;
    
    public MinStack() {
        stack = new Stack<>();
    }
```

在实际使用中，我习惯于使用Stack来构造栈:`Stack<Integer> stack = new Stack<>();`

但在很多题解中构造栈会用如下的方法：

`Deque<Integer> stack = new ArrayDeque<>();`
`Deque<Integer> stack = new LinkedList<>();`

虽然博客说：Stack(遗留类，不建议使用)，建议使用Deque(双端队列)来实现栈，但还是以自己习惯最好，就是用`Stack<Integer> stack = new Stack<>();`来构建栈就好，

[博客地址](https://blog.csdn.net/weixin_42310154/article/details/118032098)

##### 方法二：辅助栈

```java
class MinStack {

    Stack<Integer> A, B;
    public MinStack() {
        A = new Stack<>();
        B = new Stack<>();
    }
    
    public void push(int x) {
        A.add(x);
        // 判断B是否为空只在第一次push进B栈时才操作,没有这个判断则会报空栈异常
        if (B.empty() || B.peek() >= x) { // 要保证加进来的x要小于等于B栈的栈顶元素
            B.add(x);
        }
    }
    
    public void pop() {
        if (A.pop().equals(B.peek())) { // 因为是Integer，所以用equeals()代替==
            B.pop();
        }
    }
    
    public int top() {
        return A.peek();
    }
    
    public int min() {
        return B.peek();
    }
}
```

帮助理解图：分别是原始的栈和辅助的栈，同时向两个栈中存放数据，但辅助栈中只存放较小的数字

![image-20220415233951509](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220415233951509.png)



## ==哈希==

#### [**BM51** **数组中出现次数超过一半的数字**](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=295&tqId=23271&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

```java
import java.util.*;

public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        // map用来存遍历到的 数 和 这个数的发生的频率
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < array.length; i++) {
            if (!map.containsKey(array[i])) {
                map.put(array[i], 1);
            } else {
                // 进到这步，说明map中已经存在，那么将频度加1
                map.put(array[i], map.get(array[i]) + 1);
            }
            if (map.get(array[i]) > array.length / 2) {
                return array[i];
            }
        }
        return -1;
    }
}
```

当map中不存在此元素时的put操作，有点东西的。

==HashMap是put()、 containsKey()、containsValue()、remove()、get()==

==HashSet是add()、contains()、remove()，注意HashSet没有get方法==



#### [**BM52** **数组中只出现一次的两个数字**](https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=295&tqId=1375231&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型一维数组 
     * @return int整型一维数组
     */
    public int[] FindNumsAppearOnce (int[] array) {
        // write code here
        int[] target = new int[2];
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int num : array) {
            if (map.containsKey(num)) {
                // map已经包含该值，取出该值的频率，并加1
                map.put(num, map.get(num) + 1);
            } else {
                // map不包含该值，比如4
                map.put(num, 1);
            }
        }
        int j = 0; // j用于记录数组第一个和第二个元素的下标
        for (int i : map.keySet()) {
            if (map.get(i) == 1) {   
                target[j] = i;
                j++;
            }
        }
        return target;
    }
}
```

==本题还可以尝试使用位运算的方式做，以后尝试==



#### [**BM50** **两数之和**](https://www.nowcoder.com/practice/20ef0972485e41019e39543e8e895b7f?tpId=295&tqId=745&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

```java
public class Solution {
    public int[] twoSum (int[] nums, int target) {        
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.get(target - nums[i]) != null) {
                return new int[]{map.get(target - nums[i]) + 1, i + 1};
            } else {
                map.put(nums[i], i);
            }
        }
        return new int[]{0, 0};
    }
}
```



#### [**HJ23** **删除字符串中出现次数最少的字符**](https://www.nowcoder.com/practice/05182d328eb848dda7fdd5e029a56da9?tpId=37&tqId=21246&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26pageSize%3D50%26search%3D%25E5%2588%25A0%25E9%2599%25A4%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E4%25B8%25AD%25E5%2587%25BA%25E7%258E%25B0%25E6%25AC%25A1%25E6%2595%25B0%25E6%259C%2580%25E5%25B0%2591%25E7%259A%2584%25E5%25AD%2597%25E7%25AC%25A6%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%B0%91%E7%9A%84%E5%AD%97%E7%AC%A6)

```java
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args){
        //标准输入
        Scanner sc=new Scanner(System.in);       
        while(sc.hasNext()){
            //用于记录字符出现次数
            HashMap<Character,Integer> map=new HashMap<>();
            String s=sc.nextLine();
            for(int i=0;i<s.length();i++){
                char c=s.charAt(i);
                //如果不包含，设定次数为1
                if(!map.containsKey(c)){
                    map.put(c,1);
                }
                //如果包含，在原来次数基础上加1
                else{
                    map.put(c,map.get(c)+1);
                }
            }
            //用于计算最小出现次数
            int min=20;
            for(char c:map.keySet()){
                min=Math.min(min,map.get(c));
            }
            //记录删除出现次数最少字符后的字符串
            StringBuilder res=new StringBuilder();
            for(int i=0;i<s.length();i++){
                char c=s.charAt(i);
                if(map.get(c)!=min){
                    res.append(c);
                }
            }
            System.out.println(res.toString());
        }
    }
}
```

华为笔试的输入输出题，这题用于练习对map集合二次加工求解的题目，也就是用keySet()来再次增强for遍历map集合



#### [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        // 去重
        HashSet<Integer> set = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            if (!set.contains(nums[i])) {
                set.add(nums[i]);
            }
        }
        int maxLen = 0;
        /**
      若当前遍历的数减一已经存在set中，则此数开头的序列必不可能最长，直接跳过进行下一次遍历，
      若此数减一不存在set中，则进行加一，再次判断是否在set中，直至跳出循环，更新长度
         */
        for (Integer num : set) {
            if (!set.contains(num - 1)) {
                int cur = num;
                int curLen = 1;
                while (set.contains(cur + 1)) {
                    cur++;
                    curLen++;
                }
                maxLen = Math.max(maxLen, curLen);
            }
        }
        return maxLen;
    }
}

```

**哈希**



#### [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

```java
class Solution {
    public int singleNumber(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int num :nums) {
            if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
            } else {
                map.put(num, 1);
            }
        }
        // 关键
        Set<Integer> set = map.keySet();
        for (int i : set) {
            if (map.get(i) == 1) {
                return i;
            }
        }
        return -1;
    }
}
```





## ==贪心==

#### [135. 分发糖果](https://leetcode.cn/problems/candy/)

#### [**BM95** **分糖果问题**](https://www.nowcoder.com/practice/76039109dd0b47e994c08d8319faa352?tpId=295&tqId=1008104&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

题解：[K神](https://leetcode-cn.com/problems/candy/solution/candy-cong-zuo-zhi-you-cong-you-zhi-zuo-qu-zui-da-/)

```java
class Solution {
    public int candy(int[] ratings) {
        int[] left  = new int[ratings.length];
        int[] right  = new int[ratings.length];
        Arrays.fill(left, 1);
        Arrays.fill(right, 1);
        for(int i = 1; i < ratings.length; i++) {
            if (ratings[i] > ratings[i - 1]) {
                left[i] = left[i - 1] + 1;
            }
        }
        int count = left[ratings.length - 1];
        //从右到左遍历的时候，为了防止数组下标溢出，从ratings.length - 1开始遍历，相当于跳过了倒数第一个元素，所以count要初始化为left[ratings.length - 1]
        for(int i = ratings.length - 2; i >= 0; i--) {
            if(ratings[i] > ratings[i + 1]) {
                right[i] = right[i + 1] + 1;
            }
            count += Math.max(left[i], right[i]);
        }
        return count;
    }
}
```

经历过左到右、右到左两次遍历后，如下图所示：([参见K神题解](https://leetcode-cn.com/problems/candy/solution/candy-cong-zuo-zhi-you-cong-you-zhi-zuo-qu-zui-da-/))

![image-20220415223812824](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220415223812824.png)



#### [**BM96** **主持人调度（二）**](https://www.nowcoder.com/practice/4edf6e6d01554870a12f218c94e8a299?tpId=295&tqId=1267319&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

```java
import java.util.*;

public class Solution {
    public int minmumNumberOfHost (int n, int[][] startEnd) {
        int[] start = new int[n];
        int[] end = new int[n];
        for (int i = 0; i < n; i++) {
            start[i] = startEnd[i][0];
            end[i] = startEnd[i][1];
        }
        Arrays.sort(start, 0, start.length);
        Arrays.sort(end, 0, start.length);
        int res = 0;
        int j = 0;
        for (int i = 0; i < n; i++) {
            if (start[i] >= end[j]) {
                j++;
            } else {
                res++;
            }
        }
        return res;
    }
}
```

自测输入：`3,[[1,3],[3,4],[3,5]]`

用idea调试：

![image-20220416140013047](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220416140013047.png)

start[]: [1, 3, 3]

end[]: [3, 4, 5]

本题我觉得比较妙的地方在于变量j，j一开始是0，先将start[0]和end[0]即1和3比较，发现1小于3，这个时候主持人数res加1，j不变仍为0，然后再将start[1]与end[0]相比较(注意是end[0]儿2不是end[1])，发现start[1]小于等于了end[0]，所以此时将j加1，依次类推，到最后。保证每次i进位时，要么是主持人数res加1要么是j加1。









## ==模拟（找规律）==

#### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {

        List<Integer> res = new LinkedList<>();

        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return res;
        }
            
        int left = 0; //左
        int right = matrix[0].length - 1; //右
        int up = 0; //上
        int down = matrix.length - 1; //下
        
        // 助记：res中add什么，接下来就增或者减什么，然后再for中用它
        while (left <= right && up <= down){
            for (int i = left; i <= right; i++) {
                res.add(matrix[up][i]);
            }
            up++;
            for (int i = up; i <= down; i++) {
                res.add(matrix[i][right]);
            }
            right--;
            for (int i = right; i >= left && up <= down; i--) {
                res.add(matrix[down][i]);
            }
            down--;
            for (int i = down; i >= up && left <= right; i--) {
                res.add(matrix[i][left]);
            }
            left++;
        }
        return res;                      
    }
}
```

帮助记忆：

![image-20220518170039681](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220518170039681.png)



#### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

```java
class Solution {
    public void rotate(int[][] matrix) {
        int m = matrix.length;
        for (int i = 0; i < m; i++) {
            for (int j = i; j < m; j++) {
                // swap(matrix[i][j], matrix[j][i]);
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = tmp;
            }
        }
        // 旋转每一列
        for (int[] lie : matrix) {
            reverse(lie);
        }
    }

    // 一维数组的旋转，相当于将"hello world"变成"dlrow olleh"
    private void reverse(int[] arr) {
        int i = 0;
        int j = arr.length - 1;
        while (i < j) {
            // swap(arr[i], arr[j]);
            int tmp  =arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
            i++;
            j--;
        }
    }
}
```

[题解参见东哥](https://labuladong.github.io/algo/2/18/24/)

图解：

要对n*n的矩阵进行如下的顺时针旋转，可以分两步：

1. **先按轴镜像旋转**

![img](https://labuladong.github.io/algo/images/花式遍历/2.jpeg)

2. **再按照每一列进行旋转**

![img](https://labuladong.github.io/algo/images/花式遍历/3.jpeg)

至此就发现 **`matrix` 顺时针旋转 90 度的结果就是我们想要的**：

![img](https://labuladong.github.io/algo/images/花式遍历/4.jpeg)





#### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

```java
class Solution {

    private ListNode dummyHead = new ListNode(-1);
    private ListNode tail = dummyHead;

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode iterator1 = l1, iterator2 = l2;
        int carry = 0;
        // 自左向右求和进位
        while (iterator1 != null && iterator2 != null) {
            int val = (iterator1.val + iterator2.val + carry) % 10;
            carry = (iterator1.val + iterator2.val + carry) / 10;
            appendNode(new ListNode(val));
            iterator1 = iterator1.next;
            iterator2 = iterator2.next;
        }

        while (iterator1 != null) {
            int val = (iterator1.val + carry) % 10;
            carry = (iterator1.val + carry) / 10;
            appendNode(new ListNode(val));
            iterator1 = iterator1.next;
        }

        while (iterator2 != null) {
            int val = (iterator2.val + carry) % 10;
            carry = (iterator2.val + carry) / 10;
            appendNode(new ListNode(val));
            iterator2 = iterator2.next;
        }

        if (carry != 0) {
            appendNode(new ListNode(carry));
        }
        return dummyHead.next;
    }

        //  将节点加入链表
        private void appendNode(ListNode node) {
            tail.next = node;
            tail = node;
        }
}
```

因为这个相加得逻辑是从左到右的，所以不知道l1和l2谁先相加完，所以要进行判断，还有就是最右边的进位1要进行判断，因此总共分为下面的四步：

![image-20220514114658688](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220514114658688.png)









## ==双指针==

#### [**BM97** **旋转数组**](https://www.nowcoder.com/practice/e19927a8fd5d477794dac67096862042?tpId=295&tqId=1024689&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

```java
import java.util.*;


public class Solution {
public int[] solve (int n, int m, int[] a) {
    
        m = m % n;
        // 0 - n
        reverse(a,0,n-1);
        // 0 - m
        reverse(a,0,m-1);
        // m - n
        return reverse(a,m,n-1);
    }
    private int[] reverse(int[] a,int start,int end){
        while(start < end){
            int tmp = a[start];
            a[start] = a[end];
            a[end] = tmp;
            start++;
            end--;
        }
        return a;
    }
}
```



#### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 0;
        int fast = 0;
        while (fast < nums.length) {
            if (nums[slow] != nums[fast]) {
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
        }
        // 数组长度为索引 + 1
        return slow + 1;
    }
}
```





## ==二分法==

#### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int l = 0;
        int r = n - 1;
        while (l <= r) {
            int mid  = (l + r) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            // target在[nums[0], nums[mid]]
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target <= nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                // target在[nums[mid], nums[n - 1]]
                if (nums[mid] <= target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
}
```



#### [**BM18** **二维数组中的查找**](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=295&tqId=23256&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

[参考视频](https://www.bilibili.com/video/BV12J411i7A6?spm_id_from=333.337.search-card.all.click)

```java
public class Solution {
    public boolean Find(int target, int [][] array) {
        int m = array.length; // 行
        int n = array[0].length; // 列
        
        // 初始化确定第一行最后一个元素作为初始的“中间的点”，后续更新该点
        int x = 0;
        int y = array[0].length - 1;
        while (x < m && y >= 0) {
            if (array[x][y] == target) {
                return true;
            } else if (array[x][y] < target) {
                // 因为该行都比target小了。所以下移一行
                x++;
            } else if (array[x][y] > target) {
                // 因为该列都比target大了。所以左移一列
                y--;
            }
        }
        return false;
    }
}
```

解题核心：**第一行最后一个元素作为初始的“中间的点”**

注意框中的一串数字 1、2、3、4、7、9、10是一个递增的数，因此本题可用二分法，来完成查找，这题易错的是边缘点的判别要么出现ArrayIndexOutOfBoundsException要么就是样例有的通过不了。判断条件`x < m && y >= 0`的助记：可以大于等于0，但不可以小于等于m，因为数组是从0开始到m - 1结束的。

![image-20220328153731215](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220328153731215.png)

[**BM19** **寻找峰值**](https://www.nowcoder.com/practice/fcf87540c4f347bcb4cf720b5b350c76?tpId=295&tqId=2227748&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

牛客的高频题目

答案

```java
public int findPeakElement(int[] nums) {
        int idx = 0;
        for (int i = 1; i < nums.length; ++i) {
            if (nums[i] > nums[idx]) {
                idx = i; // 因为nums是无限长的，所以找到一个比当前i大的值即可
            }
        }
        return idx;
    }
```

奇淫巧计：根据题目的意思，两个端点值是-∞（且元素不重复），**只需要一直找最大的值，那么这个值一定是波峰**



我受上面的最长回文子串的影响，写了下面的错误代码,通过15/20的示例，是没有考虑到只能比单侧大的情况，因为我认为两侧都小于才算峰值。

```java
public int findPeakElement (int[] nums) {
    // write code here
    if (nums.length == 0 || nums.length == 1) return 0;
    for (int i = 0; i < nums.length; i++) {
        int left = i - 1;
        int right = i + 1;
        if (left > 0 && right < nums.length) {
            if (nums[i] > nums[left] && nums[i] > nums[right]) {
                return i;
            }
        }
    }
    return 0;
}
```



#### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

```java
class Solution {
    public int mySqrt(int x) {
        int left = 1;
        // 加速，将x中部位置加1作为右节点
        int right = x / 2 + 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (mid == x / mid) {
                return mid;
            } else if (mid > x / mid){
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return right;
    }
}
```



#### [50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

```java
class Solution {
    public double myPow(double x, int n) {
        if (n == Integer.MIN_VALUE) return 1 / (myPow(x, Integer.MAX_VALUE) / x);
        if (n == 0) return 1;
        if (n < 0) return 1 / myPow(x, -n);
        double res = myPow(x, n /2);
        if (n % 2 == 1) return res * res * x;
        else return res * res;
    }
}
```

[参考题解](https://www.bilibili.com/video/BV1RA4y197Bs?spm_id_from=333.337.search-card.all.click&vd_source=35aeaee52b15e78b11967f5ef3ce655a)，二分法，注意n取最小值的时候会越界



## ==直来直去的题目（翻译题意）==

#### [169. 多数元素](https://leetcode.cn/problems/majority-element/)

```java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        int tmp = nums[0];
        for (int i = 0; i < nums.length; i++) {
            if (tmp == nums[i]) {
                count++;
            } else {
                count--;
                if (count == 0) {
                    tmp = nums[i + 1];
                }
            }
        }
        return tmp;
    }
}
```

评论区：从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个



## ==最基础的题目==

#### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] res = new int[2];
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    res[0] = i;
                    res[1] = j;
                }
            }
        }
        return res;
    }
}
```





## ==SQL==

![图片说明](http://milessg.oss-cn-beijing.aliyuncs.com/img/B582F051A5D4976BF84E21A4B8B107C5)

[**SQL10** **用where过滤空值练习**](https://www.nowcoder.com/practice/08c9846a423540319eea4be44e339e35?tpId=199&tqId=1971605&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%25E7%25AF%2587%26topicId%3D199) 过滤null用**IS NOT**关键字，不要用**!=**

[**SQL15** **查看学校名称中含北京的用户**](https://www.nowcoder.com/practice/95d9922b1e2a49de80daa491889969ee?tpId=199&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%25E7%25AF%2587%26topicId%3D199) `where university like '北京%'`

[**SQL18** **分组计算练习题**](https://www.nowcoder.com/practice/009d8067d2df47fea429afe2e7b9de45?tpId=199&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%25E7%25AF%2587%26topicId%3D199) 按性别和学校分成两组用`GROUP BY gender, university`

![image-20220526181952190](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220526181952190.png)

[**SQL25** **查找山东大学或者性别为男生的信息**](https://www.nowcoder.com/practice/979b1a5a16d44afaba5191b22152f64a?tpId=199&tqId=1975677&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%25E7%25AF%2587%26topicId%3D199)

![image-20220526211012549](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220526211012549.png)

```sql
SELECT
  device_id,
  gender,
  age,
  gpa
FROM
  user_profile
where
  university = '山东大学'
union all
SELECT
  device_id,
  gender,
  age,
  gpa
FROM
  user_profile
where
  gender = 'male'
```

**两个表重复使用**



[**SQL26** **计算25岁以上和以下的用户数量**](https://www.nowcoder.com/practice/30f9f470390a4a8a8dd3b8e1f8c7a9fa?tpId=199&tqId=1975678&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%25E7%25AF%2587%26topicId%3D199)

![image-20220526211914974](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220526211914974.png)

 `IF(expr,v1,v2)`: 如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。

```sql
SELECT
  if (age >= 25, '25岁及以上', '25岁以下') as age_cut,
  count(device_id) as number
from
  user_profile
Group by
  age_cut
```

针对上面这题可以使用case-when来做，比如下面这题[**SQL27** **查看不同年龄段的用户明细**](https://www.nowcoder.com/practice/ae44b2b78525417b8b2fc2075b557592?tpId=199&tqId=1975679&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%25E7%25AF%2587%26topicId%3D199)

















## 大厂笔试ACM模式

#### [**不相邻取数**](https://www.nowcoder.com/practice/a2be806a0e5747a088670f5dc62cfa1e)

![image-20220518171351419](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220518171351419.png)

```java
import java.util.*;

public class Main{
    public  static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        while (scan.hasNext()) {
            int len = scan.nextInt();
            long[] arr = new long[len];
            for (int i = 0; i < len; i++) {
                arr[i] = scan.nextLong();
            }
            long[] dp = new long[len];
            dp[0] = arr[0];
            if (len >= 2) {
                dp[1] =  arr[1];
                if (len >=3){
                    dp[2] = arr[2]+arr[0];
                }
            }
            for (int i = 3; i < len; i++) {
                dp[i] = Math.max(dp[i - 2] + arr[i], dp[i - 3] + arr[i]);
            }
            Arrays.sort(dp);
            System.out.print(dp[len - 1]);
        }
    }
}

```

**动态规划**





## ==速记算法==

![image-20220615111051980](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615111051980.png)

![image-20220615111125322](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615111125322.png)

-------------

![image-20220615111155537](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615111155537.png)

![image-20220615111228150](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615111228150.png)



----------------------

![image-20220615111307686](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615111307686.png)

![image-20220615111336425](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615111336425.png)

-----------------

![image-20220615111403575](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615111403575.png)

![image-20220615111516645](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615111516645.png)

------

![image-20220615134348559](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615134348559.png)

![image-20220615134401056](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615134401056.png)

----------

![image-20220615141903711](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615141903711.png)

![image-20220615141929212](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615141929212.png)

------

![image-20220615143432196](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615143432196.png)

![image-20220615143520858](http://milessg.oss-cn-beijing.aliyuncs.com/img/image-20220615143520858.png)

-------























小结：

String转成int 用 Integer.parseInt(String str) 方法

将其他类型转成String，比如将char转成String 用String.valueOf(char a)









































